   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	store_clear
  12               	store_clear:
  13               	.LFB11:
  14               		.file 1 "src/main.c"
   1:src/main.c    **** #include <avr/interrupt.h>
   2:src/main.c    **** #include <avr/io.h>
   3:src/main.c    **** #include <avr/eeprom.h>
   4:src/main.c    **** #include <stdio.h>
   5:src/main.c    **** #include <util/delay.h>
   6:src/main.c    **** #include "lcd.h"
   7:src/main.c    **** #include "dmx.h"
   8:src/main.c    **** #include "adc.h"
   9:src/main.c    **** #include "hardware.h"
  10:src/main.c    **** 
  11:src/main.c    **** 
  12:src/main.c    **** 
  13:src/main.c    **** typedef enum {
  14:src/main.c    **** 	MENU_SPLASH =0,
  15:src/main.c    **** 	MENU_MAIN = 1,
  16:src/main.c    **** 	MENU_SETUP = 2,
  17:src/main.c    **** 	MENU_EDIT_CAM = 3,
  18:src/main.c    **** 	MENU_STORE = 4,
  19:src/main.c    **** 	MENU_CLEAR = 5,
  20:src/main.c    **** 	MENU_INVALID = 255
  21:src/main.c    **** } menu_identifiers;
  22:src/main.c    **** 
  23:src/main.c    **** typedef void(*menu_button)(void);
  24:src/main.c    **** typedef void(*init_function)(void);
  25:src/main.c    **** 
  26:src/main.c    **** // This struct defines a menu page
  27:src/main.c    **** // Each page contains the 4 LCD lines, the ID of the reachable menues, callbacks for each buttons a
  28:src/main.c    **** //
  29:src/main.c    **** typedef struct
  30:src/main.c    **** {
  31:src/main.c    **** 	char* lines[4];				//Display content
  32:src/main.c    **** 	menu_identifiers next[4];	//Menu to reach if a softkey is pressed
  33:src/main.c    **** 	menu_button cb[4];			//Callback for buttonpresses
  34:src/main.c    **** 	init_function init;			//Init function
  35:src/main.c    **** 	
  36:src/main.c    **** } menu_t;
  37:src/main.c    **** 
  38:src/main.c    **** //Struct for cam data
  39:src/main.c    **** #define PARAM_COUNT 7
  40:src/main.c    **** #define CAM_COUNT 4
  41:src/main.c    **** #define STORE_COUNT 4
  42:src/main.c    **** typedef struct  {
  43:src/main.c    **** 	uint16_t base_addr;		//DMX base address
  44:src/main.c    **** 	uint16_t pan_address;	//Offset of pan address from base
  45:src/main.c    **** 	uint16_t tilt_address;	//Offset of tilt address from base
  46:src/main.c    **** 	uint16_t pan_invert;	//Invert pan? (0/1)
  47:src/main.c    **** 	uint16_t tilt_invert;	//Invert tilt? (0/1)
  48:src/main.c    **** 	uint16_t pan_scaling;  
  49:src/main.c    **** 	uint16_t tilt_scaling;
  50:src/main.c    **** 	uint8_t pan;			//Pan value (send over DMX)
  51:src/main.c    **** 	uint8_t tilt;			//Tilt value (send over DMX)
  52:src/main.c    **** 
  53:src/main.c    **** 	uint16_t store_pan[STORE_COUNT];	//Stored positions
  54:src/main.c    **** 	uint16_t store_tilt[STORE_COUNT];
  55:src/main.c    **** } cam_data_t;
  56:src/main.c    **** 
  57:src/main.c    **** void setup_cam_up(void);
  58:src/main.c    **** void setup_cam_down(void);
  59:src/main.c    **** void setup_show_cam(void);
  60:src/main.c    **** void param_next(void);
  61:src/main.c    **** void param_up(void);
  62:src/main.c    **** void param_down(void);
  63:src/main.c    **** void param_show(void);
  64:src/main.c    **** void param_resetId(void);
  65:src/main.c    **** void main_show(void);
  66:src/main.c    **** void store_clear(void);
  67:src/main.c    **** void save_data(void);
  68:src/main.c    **** void set_menu(menu_identifiers menu);
  69:src/main.c    **** void process_menu(void);
  70:src/main.c    **** void process_inputs(void);
  71:src/main.c    **** void update_leds(void);
  72:src/main.c    **** 
  73:src/main.c    **** 
  74:src/main.c    **** //###########################
  75:src/main.c    **** //  Global variables
  76:src/main.c    **** //###########################
  77:src/main.c    **** menu_identifiers active_menu;
  78:src/main.c    **** cam_data_t cams[CAM_COUNT];	//Data for each cam
  79:src/main.c    **** cam_data_t backup_cams[CAM_COUNT] EEMEM; //store CAM Data in eeprom
  80:src/main.c    **** uint8_t active_cam; //remember the active cam
  81:src/main.c    **** 
  82:src/main.c    **** //Define the menu structure
  83:src/main.c    **** menu_t menues[] =
  84:src/main.c    **** { 	
  85:src/main.c    **** 	{ //MENU_SPLASH
  86:src/main.c    **** 		.lines = { "DragonVideo        ","By Karrn            ","Cam controller      ","                2
  87:src/main.c    **** 		.next =  { MENU_MAIN,MENU_MAIN,MENU_MAIN,MENU_MAIN},
  88:src/main.c    **** 		.cb =    { NULL,NULL,NULL,NULL},
  89:src/main.c    **** 		.init =  NULL
  90:src/main.c    ****     },
  91:src/main.c    **** 	{ //MENU_MAIN
  92:src/main.c    **** 		.lines = { "DragonVideo        ","                    ","                    ","STORE          SE
  93:src/main.c    **** 		.next  = { MENU_STORE, MENU_INVALID,MENU_INVALID,MENU_SETUP},
  94:src/main.c    **** 		.cb    = { NULL,NULL,NULL,NULL},
  95:src/main.c    **** 		.init  = main_show
  96:src/main.c    **** 	},
  97:src/main.c    **** 	{ //MENU_SETUP
  98:src/main.c    **** 		.lines = { "Setup              ","                    ","                    ","PREV NEXT MOD.  B
  99:src/main.c    **** 		.next  = { MENU_INVALID,MENU_INVALID,MENU_EDIT_CAM,MENU_MAIN},
 100:src/main.c    **** 		.cb    = { setup_cam_down,setup_cam_up,param_resetId,save_data},
 101:src/main.c    **** 		.init =  setup_show_cam
 102:src/main.c    **** 	},
 103:src/main.c    **** 	{ //MENU_EDIT_CAM
 104:src/main.c    **** 		.lines = { "Setup              ","                    ","                    ","NEXT UP   DOWN  B
 105:src/main.c    **** 		.next  = { MENU_INVALID,MENU_INVALID,MENU_INVALID,MENU_SETUP},
 106:src/main.c    **** 		.cb    = { param_next,param_up, param_down, NULL},
 107:src/main.c    **** 		.init  = param_show
 108:src/main.c    **** 	},
 109:src/main.c    **** 	{ //MENU_STORE
 110:src/main.c    **** 		.lines = { "Store              ","Choose store to save","                    ","     CLEAR     AB
 111:src/main.c    **** 		.next  = { MENU_INVALID,MENU_CLEAR,MENU_INVALID,MENU_MAIN},
 112:src/main.c    **** 		.cb    = { NULL,NULL, NULL, NULL},
 113:src/main.c    **** 		.init  = NULL
 114:src/main.c    **** 	},
 115:src/main.c    **** 	{ //MENU_CLEAR
 116:src/main.c    **** 		.lines = { "Clear store        ","Choose store        ","                    ","ALL            AB
 117:src/main.c    **** 		.next  = { MENU_MAIN,MENU_INVALID,MENU_INVALID,MENU_MAIN},
 118:src/main.c    **** 		.cb    = { store_clear,NULL, NULL, NULL},
 119:src/main.c    **** 		.init  = NULL
 120:src/main.c    **** 	}
 121:src/main.c    **** };
 122:src/main.c    **** 
 123:src/main.c    **** 
 124:src/main.c    **** 
 125:src/main.c    **** 
 126:src/main.c    **** 
 127:src/main.c    **** //Hauptprogramm
 128:src/main.c    **** int main (void) 
 129:src/main.c    **** {  
 130:src/main.c    **** 	//initialise stuff
 131:src/main.c    **** 	hardware_init();
 132:src/main.c    **** 	eeprom_read_block (cams, backup_cams, sizeof(cams));
 133:src/main.c    **** 
 134:src/main.c    **** 	lcd_init(LCD_DISP_ON);
 135:src/main.c    **** 	set_menu(MENU_SPLASH);
 136:src/main.c    **** 	dmx_init();
 137:src/main.c    **** 	ADC_Init();
 138:src/main.c    **** 
 139:src/main.c    **** 	set_cam_leds(active_cam);
 140:src/main.c    **** 	uint16_t blink_counter=0;
 141:src/main.c    **** 	while(1)
 142:src/main.c    **** 	{
 143:src/main.c    **** 		blink_counter++;
 144:src/main.c    **** 
 145:src/main.c    **** 		//Process analog inputs, cam changes and store requests
 146:src/main.c    **** 		process_inputs();
 147:src/main.c    **** 		
 148:src/main.c    **** 		//Process the menu system  / softkeys
 149:src/main.c    **** 		process_menu();
 150:src/main.c    **** 		
 151:src/main.c    **** 
 152:src/main.c    **** 		//The STORE-LEDs should flash if MENU_STORE or MENU_CLEAR is selected
 153:src/main.c    **** 		if((active_menu == MENU_STORE || active_menu == MENU_CLEAR) && blink_counter % 20 == 0)
 154:src/main.c    **** 		{
 155:src/main.c    **** 			for(int i=0; i < STORE_COUNT; i++)
 156:src/main.c    **** 				reset_store_led(i);
 157:src/main.c    **** 		}
 158:src/main.c    **** 
 159:src/main.c    **** 		if((active_menu == MENU_STORE || active_menu == MENU_CLEAR )&& blink_counter % 40 == 0)
 160:src/main.c    **** 		{
 161:src/main.c    **** 			for(int i=0; i < STORE_COUNT; i++)
 162:src/main.c    **** 				set_store_led(i);
 163:src/main.c    **** 		}
 164:src/main.c    **** 
 165:src/main.c    **** 
 166:src/main.c    **** 		//awkward delay here.. should be replaced by a timer. But it works, DMX is interrupt-driven
 167:src/main.c    **** 		_delay_ms(5);
 168:src/main.c    **** 	}
 169:src/main.c    **** }
 170:src/main.c    **** 
 171:src/main.c    **** void update_leds(void)
 172:src/main.c    **** {
 173:src/main.c    **** 	//update the store leds if the leds are not flashing
 174:src/main.c    **** 	if( ! (active_menu == MENU_STORE || active_menu == MENU_CLEAR))
 175:src/main.c    **** 	{
 176:src/main.c    **** 		for(int i=0; i < STORE_COUNT; i++)
 177:src/main.c    **** 		{
 178:src/main.c    **** 			//0xFFFF marks an empty store
 179:src/main.c    **** 			if(cams[active_cam].store_pan[i]!= 0xFFFF && cams[active_cam].store_tilt[i]!= 0xFFFF)
 180:src/main.c    **** 			{
 181:src/main.c    **** 				set_store_led(i);
 182:src/main.c    **** 			}
 183:src/main.c    **** 			else
 184:src/main.c    **** 			{
 185:src/main.c    **** 				reset_store_led(i);
 186:src/main.c    **** 			}
 187:src/main.c    **** 		}
 188:src/main.c    **** 	}
 189:src/main.c    **** 
 190:src/main.c    **** }
 191:src/main.c    **** 
 192:src/main.c    **** 
 193:src/main.c    **** 
 194:src/main.c    **** void process_inputs(void)
 195:src/main.c    **** {
 196:src/main.c    **** 	//Fetch keypress from hardware
 197:src/main.c    **** 	camkey_t keys = get_camkeys();
 198:src/main.c    **** 
 199:src/main.c    **** 	//Change the active cam
 200:src/main.c    **** 	switch(keys)
 201:src/main.c    **** 	{
 202:src/main.c    **** 		case CAM1: active_cam = 0; break;
 203:src/main.c    **** 		case CAM2: active_cam = 1; break; 
 204:src/main.c    **** 		case CAM3: active_cam = 2; break;
 205:src/main.c    **** 		case CAM4: active_cam = 3; break;
 206:src/main.c    **** 		default: break;
 207:src/main.c    **** 	}
 208:src/main.c    **** 
 209:src/main.c    **** 	//update stuff if the cam changed
 210:src/main.c    **** 	if(keys != CAM_NO_KEY)
 211:src/main.c    **** 	{
 212:src/main.c    **** 		//camera leds
 213:src/main.c    **** 		set_cam_leds(active_cam);
 214:src/main.c    **** 
 215:src/main.c    **** 		update_leds();
 216:src/main.c    **** 
 217:src/main.c    **** 		//main screen
 218:src/main.c    **** 		if(active_menu == MENU_MAIN)
 219:src/main.c    **** 			main_show();
 220:src/main.c    **** 
 221:src/main.c    **** 	}
 222:src/main.c    **** 
 223:src/main.c    **** 	static uint8_t analog=0;
 224:src/main.c    **** 
 225:src/main.c    **** 	
 226:src/main.c    **** 	
 227:src/main.c    **** 	uint8_t old_tilt = cams[active_cam].tilt;
 228:src/main.c    **** uint8_t old_pan = cams[active_cam].pan;
 229:src/main.c    **** 	
 230:src/main.c    **** 	analog++;
 231:src/main.c    **** 	if(analog%8==0)
 232:src/main.c    **** 	{
 233:src/main.c    **** 		//fetch joystick deflection and calculate new pan
 234:src/main.c    **** 		int16_t diff = axis_offset(0, cams[active_cam].pan_scaling);
 235:src/main.c    **** 		if(cams[active_cam].pan_invert)
 236:src/main.c    **** 		{
 237:src/main.c    **** 			diff=-diff;
 238:src/main.c    **** 		}
 239:src/main.c    **** 	
 240:src/main.c    **** 		if( (int16_t)cams[active_cam].pan+diff > 255)
 241:src/main.c    **** 			cams[active_cam].pan=255;
 242:src/main.c    **** 		else if( (int16_t)cams[active_cam].pan+diff < 0)
 243:src/main.c    **** 			cams[active_cam].pan=0;
 244:src/main.c    **** 		else
 245:src/main.c    **** 			cams[active_cam].pan+=diff	;
 246:src/main.c    **** 
 247:src/main.c    **** 		//fetch joystick deflection and calculate new tilt
 248:src/main.c    **** 		diff = -axis_offset(1, cams[active_cam].tilt_scaling);
 249:src/main.c    **** 		if(cams[active_cam].tilt_invert)
 250:src/main.c    **** 		{
 251:src/main.c    **** 			diff=-diff;
 252:src/main.c    **** 		}
 253:src/main.c    **** 
 254:src/main.c    **** 
 255:src/main.c    **** 		if( (int16_t)cams[active_cam].tilt+diff > 255)
 256:src/main.c    **** 			cams[active_cam].tilt=255;
 257:src/main.c    **** 		else if( (int16_t)cams[active_cam].tilt+diff < 0)
 258:src/main.c    **** 			cams[active_cam].tilt=0;
 259:src/main.c    **** 		else
 260:src/main.c    **** 			cams[active_cam].tilt+=diff	;
 261:src/main.c    **** 	}
 262:src/main.c    **** 
 263:src/main.c    **** 	//fetch store key selection from hardware
 264:src/main.c    **** 	storekey_t store = get_storekeys();
 265:src/main.c    **** 
 266:src/main.c    **** 	if(store != STORE_NO_KEY)
 267:src/main.c    **** 	{
 268:src/main.c    **** 		uint8_t store_id=0;
 269:src/main.c    **** 
 270:src/main.c    **** 		//get store id from button
 271:src/main.c    **** 		switch(store)
 272:src/main.c    **** 		{
 273:src/main.c    **** 			case STORE1: store_id = 0; break;
 274:src/main.c    **** 			case STORE2: store_id = 1; break;
 275:src/main.c    **** 			case STORE3: store_id = 2; break;
 276:src/main.c    **** 			case STORE4: store_id = 3; break;
 277:src/main.c    **** 			default: break;
 278:src/main.c    **** 		}
 279:src/main.c    **** 
 280:src/main.c    **** 		//if the current menu is store, save the data, else read or clear
 281:src/main.c    **** 		if(active_menu == MENU_STORE)
 282:src/main.c    **** 		{
 283:src/main.c    **** 			cams[active_cam].store_pan[store_id] = cams[active_cam].pan;
 284:src/main.c    **** 			cams[active_cam].store_tilt[store_id] = cams[active_cam].tilt;
 285:src/main.c    **** 			save_data(); //write data to EEPROM
 286:src/main.c    **** 			set_menu(MENU_MAIN); //jump back to main menu
 287:src/main.c    **** 		}
 288:src/main.c    **** 		else if(active_menu == MENU_CLEAR) //if the current menu is clear, clear the selected slot
 289:src/main.c    **** 		{
 290:src/main.c    **** 			cams[active_cam].store_pan[store_id]=0xFFFF;
 291:src/main.c    **** 			cams[active_cam].store_tilt[store_id]=0xFFFF;
 292:src/main.c    **** 			save_data(); //write data to EEPROM
 293:src/main.c    **** 			set_menu(MENU_MAIN); //jump back to main menu
 294:src/main.c    **** 		}
 295:src/main.c    **** 		else //load stored values
 296:src/main.c    **** 		{
 297:src/main.c    **** 			//can not load empty store
 298:src/main.c    **** 			if(cams[active_cam].store_pan[store_id]!= 0xFFFF &&  cams[active_cam].store_tilt[store_id] != 0x
 299:src/main.c    **** 			{
 300:src/main.c    **** 				cams[active_cam].pan = cams[active_cam].store_pan[store_id]; 
 301:src/main.c    **** 				cams[active_cam].tilt = cams[active_cam].store_tilt[store_id];;
 302:src/main.c    **** 			}
 303:src/main.c    **** 		}
 304:src/main.c    **** 
 305:src/main.c    **** 	}
 306:src/main.c    **** 
 307:src/main.c    **** 	//if tilt or pan changed
 308:src/main.c    **** 	if(old_tilt != cams[active_cam].tilt || old_pan != cams[active_cam].pan)
 309:src/main.c    **** 	{
 310:src/main.c    **** 		//write values to DMX
 311:src/main.c    **** 		write_dmx(cams[active_cam].base_addr + cams[active_cam].pan_address, cams[active_cam].pan);
 312:src/main.c    **** 		write_dmx(cams[active_cam].base_addr + cams[active_cam].tilt_address, cams[active_cam].tilt);
 313:src/main.c    **** 
 314:src/main.c    **** 		//update main menu
 315:src/main.c    **** 		if(active_menu == MENU_MAIN)
 316:src/main.c    **** 			main_show();
 317:src/main.c    **** 	}	
 318:src/main.c    **** 
 319:src/main.c    **** }
 320:src/main.c    **** 
 321:src/main.c    **** void store_clear(void)
 322:src/main.c    **** {
  15               		.loc 1 322 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               	.LBB6:
 323:src/main.c    **** 	for(uint8_t i=0; i < STORE_COUNT; i++)
 324:src/main.c    **** 	{
 325:src/main.c    **** 		cams[active_cam].store_pan[i] = 0xFFFF;
  23               		.loc 1 325 0
  24 0000 E091 0000 		lds r30,active_cam
  25 0004 80E2      		ldi r24,lo8(32)
  26 0006 E89F      		mul r30,r24
  27 0008 F001      		movw r30,r0
  28 000a 1124      		clr __zero_reg__
  29 000c E050      		subi r30,lo8(-(cams))
  30 000e F040      		sbci r31,hi8(-(cams))
  31 0010 8FEF      		ldi r24,lo8(-1)
  32 0012 9FEF      		ldi r25,lo8(-1)
  33 0014 918B      		std Z+17,r25
  34 0016 808B      		std Z+16,r24
 326:src/main.c    **** 		cams[active_cam].store_tilt[i] = 0xFFFF;
  35               		.loc 1 326 0
  36 0018 918F      		std Z+25,r25
  37 001a 808F      		std Z+24,r24
  38               	.LVL1:
 325:src/main.c    **** 		cams[active_cam].store_tilt[i] = 0xFFFF;
  39               		.loc 1 325 0
  40 001c 938B      		std Z+19,r25
  41 001e 828B      		std Z+18,r24
  42               		.loc 1 326 0
  43 0020 938F      		std Z+27,r25
  44 0022 828F      		std Z+26,r24
  45               	.LVL2:
 325:src/main.c    **** 		cams[active_cam].store_tilt[i] = 0xFFFF;
  46               		.loc 1 325 0
  47 0024 958B      		std Z+21,r25
  48 0026 848B      		std Z+20,r24
  49               		.loc 1 326 0
  50 0028 958F      		std Z+29,r25
  51 002a 848F      		std Z+28,r24
  52               	.LVL3:
 325:src/main.c    **** 		cams[active_cam].store_tilt[i] = 0xFFFF;
  53               		.loc 1 325 0
  54 002c 978B      		std Z+23,r25
  55 002e 868B      		std Z+22,r24
  56               		.loc 1 326 0
  57 0030 978F      		std Z+31,r25
  58 0032 868F      		std Z+30,r24
  59               	.LVL4:
  60 0034 0895      		ret
  61               	.LBE6:
  62               		.cfi_endproc
  63               	.LFE11:
  65               	.global	param_resetId
  67               	param_resetId:
  68               	.LFB22:
 327:src/main.c    **** 	}
 328:src/main.c    **** }
 329:src/main.c    **** 
 330:src/main.c    **** void main_show(void)
 331:src/main.c    **** {
 332:src/main.c    **** 	lcd_gotoxy(0,1);
 333:src/main.c    **** 	lcd_puts("Active: CAM ");
 334:src/main.c    **** 	char tmp[21];
 335:src/main.c    **** 	itoa(active_cam+1,tmp,10);
 336:src/main.c    **** 	lcd_gotoxy(12,1);
 337:src/main.c    **** 	lcd_puts(tmp);
 338:src/main.c    **** 
 339:src/main.c    **** 	lcd_gotoxy(0,2);
 340:src/main.c    **** 	sprintf(tmp,"Pan: %3d Tilt: %3d", cams[active_cam].pan, cams[active_cam].tilt);
 341:src/main.c    **** 	lcd_puts(tmp);
 342:src/main.c    **** }	
 343:src/main.c    **** 
 344:src/main.c    **** void process_menu(void)
 345:src/main.c    **** {
 346:src/main.c    **** 	softkey_t button = get_softkeys();
 347:src/main.c    **** 
 348:src/main.c    **** 	if(button != NO_KEY )
 349:src/main.c    **** 	{
 350:src/main.c    **** 		if(menues[active_menu].cb[button] != NULL)
 351:src/main.c    **** 				menues[active_menu].cb[button]();	
 352:src/main.c    **** 
 353:src/main.c    **** 		if(menues[active_menu].next[button] != MENU_INVALID)
 354:src/main.c    **** 			set_menu(menues[active_menu].next[button]);
 355:src/main.c    **** 	
 356:src/main.c    **** 					
 357:src/main.c    **** 
 358:src/main.c    **** 	}	
 359:src/main.c    **** }
 360:src/main.c    **** 
 361:src/main.c    **** void set_menu(menu_identifiers menu)
 362:src/main.c    **** {
 363:src/main.c    **** 	active_menu = menu;
 364:src/main.c    **** 	lcd_clrscr();
 365:src/main.c    **** 	lcd_puts(menues[menu].lines[0]);
 366:src/main.c    **** 	lcd_gotoxy(0,1);
 367:src/main.c    **** 	lcd_puts(menues[menu].lines[1]);
 368:src/main.c    **** 	lcd_gotoxy(0,2);
 369:src/main.c    **** 	lcd_puts(menues[menu].lines[2]);
 370:src/main.c    **** 	lcd_gotoxy(0,3);
 371:src/main.c    **** 	lcd_puts(menues[menu].lines[3]);
 372:src/main.c    **** 
 373:src/main.c    **** 	if(menues[menu].init)
 374:src/main.c    **** 		menues[menu].init();
 375:src/main.c    **** 
 376:src/main.c    **** 	update_leds();
 377:src/main.c    **** 
 378:src/main.c    **** }
 379:src/main.c    **** 
 380:src/main.c    **** uint8_t setup_active_cam=0;
 381:src/main.c    **** uint8_t param_id=0;
 382:src/main.c    **** uint16_t* changing_param;
 383:src/main.c    **** 
 384:src/main.c    **** void setup_show_cam(void)
 385:src/main.c    **** {
 386:src/main.c    **** 	lcd_gotoxy(0,1);
 387:src/main.c    **** 
 388:src/main.c    **** 	char tmp[10];
 389:src/main.c    **** 	itoa(setup_active_cam+1,tmp,10);
 390:src/main.c    **** 	lcd_puts("Edit Cam ");
 391:src/main.c    **** 	lcd_gotoxy(9,1);
 392:src/main.c    **** 	lcd_puts(tmp);
 393:src/main.c    **** }
 394:src/main.c    **** 
 395:src/main.c    **** void setup_cam_up(void)
 396:src/main.c    **** {
 397:src/main.c    **** 	setup_active_cam++;
 398:src/main.c    **** 
 399:src/main.c    **** 	if(setup_active_cam>= CAM_COUNT)
 400:src/main.c    **** 		setup_active_cam=0;
 401:src/main.c    **** 
 402:src/main.c    **** 	setup_show_cam();
 403:src/main.c    **** }
 404:src/main.c    **** 
 405:src/main.c    **** void setup_cam_down(void)
 406:src/main.c    **** {
 407:src/main.c    **** 	setup_active_cam--;
 408:src/main.c    **** 	if(setup_active_cam>= CAM_COUNT)
 409:src/main.c    **** 		setup_active_cam= CAM_COUNT-1;
 410:src/main.c    **** 
 411:src/main.c    **** 	setup_show_cam();
 412:src/main.c    **** }
 413:src/main.c    **** 
 414:src/main.c    **** void param_next(void)
 415:src/main.c    **** {
 416:src/main.c    **** 	param_id++;
 417:src/main.c    **** 
 418:src/main.c    **** 	if(param_id>=PARAM_COUNT)
 419:src/main.c    **** 		param_id=0;
 420:src/main.c    **** 
 421:src/main.c    **** 	param_show();
 422:src/main.c    **** }
 423:src/main.c    **** 
 424:src/main.c    **** void param_up(void)
 425:src/main.c    **** {
 426:src/main.c    **** 	(*changing_param)++;
 427:src/main.c    **** 	param_show();	
 428:src/main.c    **** }
 429:src/main.c    **** 
 430:src/main.c    **** void param_down(void)
 431:src/main.c    **** {
 432:src/main.c    **** 	(*changing_param)--;
 433:src/main.c    **** 	param_show();	
 434:src/main.c    **** }
 435:src/main.c    **** 
 436:src/main.c    **** void param_show(void)
 437:src/main.c    **** {
 438:src/main.c    **** 	lcd_gotoxy(14,0);
 439:src/main.c    **** 	lcd_puts("CAM ");
 440:src/main.c    **** 	char tmp[10];
 441:src/main.c    **** 	itoa(setup_active_cam+1,tmp,10);
 442:src/main.c    **** 	lcd_gotoxy(18,0);
 443:src/main.c    **** 	lcd_puts(tmp);
 444:src/main.c    **** 
 445:src/main.c    **** 
 446:src/main.c    **** 	lcd_gotoxy(0,1);
 447:src/main.c    **** 	char toDraw[20];
 448:src/main.c    **** 	switch(param_id)
 449:src/main.c    **** 	{
 450:src/main.c    **** 		case 0: lcd_puts("base_addr           "); 
 451:src/main.c    **** 				changing_param=&cams[setup_active_cam].base_addr;
 452:src/main.c    **** 		
 453:src/main.c    **** 				break;
 454:src/main.c    **** 		case 1: lcd_puts("pan offset          "); 
 455:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_address;
 456:src/main.c    **** 		
 457:src/main.c    **** 				break;
 458:src/main.c    **** 		case 2: lcd_puts("tilt offset         "); 
 459:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_address;
 460:src/main.c    **** 				break;
 461:src/main.c    **** 		case 3: lcd_puts("invert pan          "); 
 462:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_invert;
 463:src/main.c    **** 				break;
 464:src/main.c    **** 		case 4: lcd_puts("invert tilt         "); 
 465:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_invert;
 466:src/main.c    **** 				break;
 467:src/main.c    **** 		case 5: lcd_puts("pan scaling         "); 
 468:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_scaling;
 469:src/main.c    **** 				break;
 470:src/main.c    **** 		case 6: lcd_puts("tilt scaling        "); 
 471:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_scaling;
 472:src/main.c    **** 				break;
 473:src/main.c    **** 	
 474:src/main.c    **** 		
 475:src/main.c    **** 	}
 476:src/main.c    **** 
 477:src/main.c    **** 	itoa(*changing_param,toDraw,10);
 478:src/main.c    **** 	lcd_gotoxy(0,2);
 479:src/main.c    **** 	lcd_puts("                 ");
 480:src/main.c    **** 	lcd_gotoxy(0,2);
 481:src/main.c    **** 	lcd_puts(toDraw);
 482:src/main.c    **** }
 483:src/main.c    **** 
 484:src/main.c    **** void param_resetId(void)
 485:src/main.c    **** {
  69               		.loc 1 485 0
  70               		.cfi_startproc
  71               	/* prologue: function */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
 486:src/main.c    **** 	param_id=0;
  75               		.loc 1 486 0
  76 0036 1092 0000 		sts param_id,__zero_reg__
  77 003a 0895      		ret
  78               		.cfi_endproc
  79               	.LFE22:
  81               		.section	.rodata.str1.1,"aMS",@progbits,1
  82               	.LC0:
  83 0000 4564 6974 		.string	"Edit Cam "
  83      2043 616D 
  83      2000 
  84               		.text
  85               	.global	setup_show_cam
  87               	setup_show_cam:
  88               	.LFB15:
 385:src/main.c    **** 	lcd_gotoxy(0,1);
  89               		.loc 1 385 0
  90               		.cfi_startproc
  91 003c CF93      		push r28
  92               	.LCFI0:
  93               		.cfi_def_cfa_offset 3
  94               		.cfi_offset 28, -2
  95 003e DF93      		push r29
  96               	.LCFI1:
  97               		.cfi_def_cfa_offset 4
  98               		.cfi_offset 29, -3
  99 0040 CDB7      		in r28,__SP_L__
 100 0042 DEB7      		in r29,__SP_H__
 101               	.LCFI2:
 102               		.cfi_def_cfa_register 28
 103 0044 2A97      		sbiw r28,10
 104               	.LCFI3:
 105               		.cfi_def_cfa_offset 14
 106 0046 0FB6      		in __tmp_reg__,__SREG__
 107 0048 F894      		cli
 108 004a DEBF      		out __SP_H__,r29
 109 004c 0FBE      		out __SREG__,__tmp_reg__
 110 004e CDBF      		out __SP_L__,r28
 111               	/* prologue: function */
 112               	/* frame size = 10 */
 113               	/* stack size = 12 */
 114               	.L__stack_usage = 12
 386:src/main.c    **** 
 115               		.loc 1 386 0
 116 0050 61E0      		ldi r22,lo8(1)
 117 0052 80E0      		ldi r24,0
 118 0054 0E94 0000 		call lcd_gotoxy
 119               	.LVL5:
 389:src/main.c    **** 	lcd_puts("Edit Cam ");
 120               		.loc 1 389 0
 121 0058 8091 0000 		lds r24,setup_active_cam
 122 005c 90E0      		ldi r25,0
 123 005e 4AE0      		ldi r20,lo8(10)
 124 0060 50E0      		ldi r21,0
 125 0062 BE01      		movw r22,r28
 126 0064 6F5F      		subi r22,-1
 127 0066 7F4F      		sbci r23,-1
 128 0068 0196      		adiw r24,1
 129 006a 0E94 0000 		call itoa
 130               	.LVL6:
 390:src/main.c    **** 	lcd_gotoxy(9,1);
 131               		.loc 1 390 0
 132 006e 80E0      		ldi r24,lo8(.LC0)
 133 0070 90E0      		ldi r25,hi8(.LC0)
 134 0072 0E94 0000 		call lcd_puts
 135               	.LVL7:
 391:src/main.c    **** 	lcd_puts(tmp);
 136               		.loc 1 391 0
 137 0076 61E0      		ldi r22,lo8(1)
 138 0078 89E0      		ldi r24,lo8(9)
 139 007a 0E94 0000 		call lcd_gotoxy
 140               	.LVL8:
 392:src/main.c    **** }
 141               		.loc 1 392 0
 142 007e CE01      		movw r24,r28
 143 0080 0196      		adiw r24,1
 144 0082 0E94 0000 		call lcd_puts
 145               	.LVL9:
 146               	/* epilogue start */
 393:src/main.c    **** 
 147               		.loc 1 393 0
 148 0086 2A96      		adiw r28,10
 149 0088 0FB6      		in __tmp_reg__,__SREG__
 150 008a F894      		cli
 151 008c DEBF      		out __SP_H__,r29
 152 008e 0FBE      		out __SREG__,__tmp_reg__
 153 0090 CDBF      		out __SP_L__,r28
 154 0092 DF91      		pop r29
 155 0094 CF91      		pop r28
 156 0096 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	setup_cam_up
 162               	setup_cam_up:
 163               	.LFB16:
 396:src/main.c    **** 	setup_active_cam++;
 164               		.loc 1 396 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 397:src/main.c    **** 
 170               		.loc 1 397 0
 171 0098 8091 0000 		lds r24,setup_active_cam
 172 009c 8F5F      		subi r24,lo8(-(1))
 399:src/main.c    **** 		setup_active_cam=0;
 173               		.loc 1 399 0
 174 009e 8430      		cpi r24,lo8(4)
 175 00a0 00F4      		brsh .L5
 397:src/main.c    **** 
 176               		.loc 1 397 0
 177 00a2 8093 0000 		sts setup_active_cam,r24
 178 00a6 00C0      		rjmp .L6
 179               	.L5:
 400:src/main.c    **** 
 180               		.loc 1 400 0
 181 00a8 1092 0000 		sts setup_active_cam,__zero_reg__
 182               	.L6:
 402:src/main.c    **** }
 183               		.loc 1 402 0
 184 00ac 0C94 0000 		jmp setup_show_cam
 185               	.LVL10:
 186               		.cfi_endproc
 187               	.LFE16:
 189               	.global	setup_cam_down
 191               	setup_cam_down:
 192               	.LFB17:
 406:src/main.c    **** 	setup_active_cam--;
 193               		.loc 1 406 0
 194               		.cfi_startproc
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
 407:src/main.c    **** 	if(setup_active_cam>= CAM_COUNT)
 199               		.loc 1 407 0
 200 00b0 8091 0000 		lds r24,setup_active_cam
 201 00b4 8150      		subi r24,lo8(-(-1))
 408:src/main.c    **** 		setup_active_cam= CAM_COUNT-1;
 202               		.loc 1 408 0
 203 00b6 8430      		cpi r24,lo8(4)
 204 00b8 00F0      		brlo .L11
 409:src/main.c    **** 
 205               		.loc 1 409 0
 206 00ba 83E0      		ldi r24,lo8(3)
 207               	.L11:
 208 00bc 8093 0000 		sts setup_active_cam,r24
 411:src/main.c    **** }
 209               		.loc 1 411 0
 210 00c0 0C94 0000 		jmp setup_show_cam
 211               	.LVL11:
 212               		.cfi_endproc
 213               	.LFE17:
 215               		.section	.rodata.str1.1
 216               	.LC1:
 217 000a 4341 4D20 		.string	"CAM "
 217      00
 218               	.LC2:
 219 000f 6261 7365 		.string	"base_addr           "
 219      5F61 6464 
 219      7220 2020 
 219      2020 2020 
 219      2020 2020 
 220               	.LC3:
 221 0024 7061 6E20 		.string	"pan offset          "
 221      6F66 6673 
 221      6574 2020 
 221      2020 2020 
 221      2020 2020 
 222               	.LC4:
 223 0039 7469 6C74 		.string	"tilt offset         "
 223      206F 6666 
 223      7365 7420 
 223      2020 2020 
 223      2020 2020 
 224               	.LC5:
 225 004e 696E 7665 		.string	"invert pan          "
 225      7274 2070 
 225      616E 2020 
 225      2020 2020 
 225      2020 2020 
 226               	.LC6:
 227 0063 696E 7665 		.string	"invert tilt         "
 227      7274 2074 
 227      696C 7420 
 227      2020 2020 
 227      2020 2020 
 228               	.LC7:
 229 0078 7061 6E20 		.string	"pan scaling         "
 229      7363 616C 
 229      696E 6720 
 229      2020 2020 
 229      2020 2020 
 230               	.LC8:
 231 008d 7469 6C74 		.string	"tilt scaling        "
 231      2073 6361 
 231      6C69 6E67 
 231      2020 2020 
 231      2020 2020 
 232               	.LC9:
 233 00a2 2020 2020 		.string	"                 "
 233      2020 2020 
 233      2020 2020 
 233      2020 2020 
 233      2000 
 234               		.text
 235               	.global	param_show
 237               	param_show:
 238               	.LFB21:
 437:src/main.c    **** 	lcd_gotoxy(14,0);
 239               		.loc 1 437 0
 240               		.cfi_startproc
 241 00c4 CF93      		push r28
 242               	.LCFI4:
 243               		.cfi_def_cfa_offset 3
 244               		.cfi_offset 28, -2
 245 00c6 DF93      		push r29
 246               	.LCFI5:
 247               		.cfi_def_cfa_offset 4
 248               		.cfi_offset 29, -3
 249 00c8 CDB7      		in r28,__SP_L__
 250 00ca DEB7      		in r29,__SP_H__
 251               	.LCFI6:
 252               		.cfi_def_cfa_register 28
 253 00cc 6E97      		sbiw r28,30
 254               	.LCFI7:
 255               		.cfi_def_cfa_offset 34
 256 00ce 0FB6      		in __tmp_reg__,__SREG__
 257 00d0 F894      		cli
 258 00d2 DEBF      		out __SP_H__,r29
 259 00d4 0FBE      		out __SREG__,__tmp_reg__
 260 00d6 CDBF      		out __SP_L__,r28
 261               	/* prologue: function */
 262               	/* frame size = 30 */
 263               	/* stack size = 32 */
 264               	.L__stack_usage = 32
 438:src/main.c    **** 	lcd_puts("CAM ");
 265               		.loc 1 438 0
 266 00d8 60E0      		ldi r22,0
 267 00da 8EE0      		ldi r24,lo8(14)
 268 00dc 0E94 0000 		call lcd_gotoxy
 269               	.LVL12:
 439:src/main.c    **** 	char tmp[10];
 270               		.loc 1 439 0
 271 00e0 80E0      		ldi r24,lo8(.LC1)
 272 00e2 90E0      		ldi r25,hi8(.LC1)
 273 00e4 0E94 0000 		call lcd_puts
 274               	.LVL13:
 441:src/main.c    **** 	lcd_gotoxy(18,0);
 275               		.loc 1 441 0
 276 00e8 8091 0000 		lds r24,setup_active_cam
 277 00ec 90E0      		ldi r25,0
 278 00ee 4AE0      		ldi r20,lo8(10)
 279 00f0 50E0      		ldi r21,0
 280 00f2 BE01      		movw r22,r28
 281 00f4 6B5E      		subi r22,-21
 282 00f6 7F4F      		sbci r23,-1
 283 00f8 0196      		adiw r24,1
 284 00fa 0E94 0000 		call itoa
 285               	.LVL14:
 442:src/main.c    **** 	lcd_puts(tmp);
 286               		.loc 1 442 0
 287 00fe 60E0      		ldi r22,0
 288 0100 82E1      		ldi r24,lo8(18)
 289 0102 0E94 0000 		call lcd_gotoxy
 290               	.LVL15:
 443:src/main.c    **** 
 291               		.loc 1 443 0
 292 0106 CE01      		movw r24,r28
 293 0108 4596      		adiw r24,21
 294 010a 0E94 0000 		call lcd_puts
 295               	.LVL16:
 446:src/main.c    **** 	char toDraw[20];
 296               		.loc 1 446 0
 297 010e 61E0      		ldi r22,lo8(1)
 298 0110 80E0      		ldi r24,0
 299 0112 0E94 0000 		call lcd_gotoxy
 300               	.LVL17:
 448:src/main.c    **** 	{
 301               		.loc 1 448 0
 302 0116 E091 0000 		lds r30,param_id
 303 011a 8E2F      		mov r24,r30
 304 011c 90E0      		ldi r25,0
 305 011e 8730      		cpi r24,7
 306 0120 9105      		cpc r25,__zero_reg__
 307 0122 00F0      		brlo .+2
 308 0124 00C0      		rjmp .L13
 309 0126 FC01      		movw r30,r24
 310 0128 E050      		subi r30,lo8(-(gs(.L15)))
 311 012a F040      		sbci r31,hi8(-(gs(.L15)))
 312 012c 0C94 0000 		jmp __tablejump2__
 313               		.section	.progmem.gcc_sw_table,"a",@progbits
 314               		.p2align	1
 315               	.L15:
 316 0000 0000      		.word gs(.L14)
 317 0002 0000      		.word gs(.L16)
 318 0004 0000      		.word gs(.L17)
 319 0006 0000      		.word gs(.L18)
 320 0008 0000      		.word gs(.L19)
 321 000a 0000      		.word gs(.L20)
 322 000c 0000      		.word gs(.L21)
 323               		.text
 324               	.L14:
 450:src/main.c    **** 				changing_param=&cams[setup_active_cam].base_addr;
 325               		.loc 1 450 0
 326 0130 80E0      		ldi r24,lo8(.LC2)
 327 0132 90E0      		ldi r25,hi8(.LC2)
 328 0134 0E94 0000 		call lcd_puts
 329               	.LVL18:
 451:src/main.c    **** 		
 330               		.loc 1 451 0
 331 0138 8091 0000 		lds r24,setup_active_cam
 332 013c 20E2      		ldi r18,lo8(32)
 333 013e 829F      		mul r24,r18
 334 0140 C001      		movw r24,r0
 335 0142 1124      		clr __zero_reg__
 336 0144 8050      		subi r24,lo8(-(cams))
 337 0146 9040      		sbci r25,hi8(-(cams))
 338 0148 00C0      		rjmp .L22
 339               	.L16:
 454:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_address;
 340               		.loc 1 454 0
 341 014a 80E0      		ldi r24,lo8(.LC3)
 342 014c 90E0      		ldi r25,hi8(.LC3)
 343 014e 0E94 0000 		call lcd_puts
 344               	.LVL19:
 455:src/main.c    **** 		
 345               		.loc 1 455 0
 346 0152 8091 0000 		lds r24,setup_active_cam
 347 0156 20E2      		ldi r18,lo8(32)
 348 0158 829F      		mul r24,r18
 349 015a C001      		movw r24,r0
 350 015c 1124      		clr __zero_reg__
 351 015e 8050      		subi r24,lo8(-(cams+2))
 352 0160 9040      		sbci r25,hi8(-(cams+2))
 353 0162 00C0      		rjmp .L22
 354               	.L17:
 458:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_address;
 355               		.loc 1 458 0
 356 0164 80E0      		ldi r24,lo8(.LC4)
 357 0166 90E0      		ldi r25,hi8(.LC4)
 358 0168 0E94 0000 		call lcd_puts
 359               	.LVL20:
 459:src/main.c    **** 				break;
 360               		.loc 1 459 0
 361 016c 8091 0000 		lds r24,setup_active_cam
 362 0170 20E2      		ldi r18,lo8(32)
 363 0172 829F      		mul r24,r18
 364 0174 C001      		movw r24,r0
 365 0176 1124      		clr __zero_reg__
 366 0178 8050      		subi r24,lo8(-(cams+4))
 367 017a 9040      		sbci r25,hi8(-(cams+4))
 368 017c 00C0      		rjmp .L22
 369               	.L18:
 461:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_invert;
 370               		.loc 1 461 0
 371 017e 80E0      		ldi r24,lo8(.LC5)
 372 0180 90E0      		ldi r25,hi8(.LC5)
 373 0182 0E94 0000 		call lcd_puts
 374               	.LVL21:
 462:src/main.c    **** 				break;
 375               		.loc 1 462 0
 376 0186 8091 0000 		lds r24,setup_active_cam
 377 018a 20E2      		ldi r18,lo8(32)
 378 018c 829F      		mul r24,r18
 379 018e C001      		movw r24,r0
 380 0190 1124      		clr __zero_reg__
 381 0192 8050      		subi r24,lo8(-(cams+6))
 382 0194 9040      		sbci r25,hi8(-(cams+6))
 383 0196 00C0      		rjmp .L22
 384               	.L19:
 464:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_invert;
 385               		.loc 1 464 0
 386 0198 80E0      		ldi r24,lo8(.LC6)
 387 019a 90E0      		ldi r25,hi8(.LC6)
 388 019c 0E94 0000 		call lcd_puts
 389               	.LVL22:
 465:src/main.c    **** 				break;
 390               		.loc 1 465 0
 391 01a0 8091 0000 		lds r24,setup_active_cam
 392 01a4 20E2      		ldi r18,lo8(32)
 393 01a6 829F      		mul r24,r18
 394 01a8 C001      		movw r24,r0
 395 01aa 1124      		clr __zero_reg__
 396 01ac 8050      		subi r24,lo8(-(cams+8))
 397 01ae 9040      		sbci r25,hi8(-(cams+8))
 398 01b0 00C0      		rjmp .L22
 399               	.L20:
 467:src/main.c    **** 				changing_param=&cams[setup_active_cam].pan_scaling;
 400               		.loc 1 467 0
 401 01b2 80E0      		ldi r24,lo8(.LC7)
 402 01b4 90E0      		ldi r25,hi8(.LC7)
 403 01b6 0E94 0000 		call lcd_puts
 404               	.LVL23:
 468:src/main.c    **** 				break;
 405               		.loc 1 468 0
 406 01ba 8091 0000 		lds r24,setup_active_cam
 407 01be 20E2      		ldi r18,lo8(32)
 408 01c0 829F      		mul r24,r18
 409 01c2 C001      		movw r24,r0
 410 01c4 1124      		clr __zero_reg__
 411 01c6 8050      		subi r24,lo8(-(cams+10))
 412 01c8 9040      		sbci r25,hi8(-(cams+10))
 413 01ca 00C0      		rjmp .L22
 414               	.L21:
 470:src/main.c    **** 				changing_param=&cams[setup_active_cam].tilt_scaling;
 415               		.loc 1 470 0
 416 01cc 80E0      		ldi r24,lo8(.LC8)
 417 01ce 90E0      		ldi r25,hi8(.LC8)
 418 01d0 0E94 0000 		call lcd_puts
 419               	.LVL24:
 471:src/main.c    **** 				break;
 420               		.loc 1 471 0
 421 01d4 8091 0000 		lds r24,setup_active_cam
 422 01d8 20E2      		ldi r18,lo8(32)
 423 01da 829F      		mul r24,r18
 424 01dc C001      		movw r24,r0
 425 01de 1124      		clr __zero_reg__
 426 01e0 8050      		subi r24,lo8(-(cams+12))
 427 01e2 9040      		sbci r25,hi8(-(cams+12))
 428               	.L22:
 429 01e4 9093 0000 		sts changing_param+1,r25
 430 01e8 8093 0000 		sts changing_param,r24
 431               	.L13:
 477:src/main.c    **** 	lcd_gotoxy(0,2);
 432               		.loc 1 477 0
 433 01ec E091 0000 		lds r30,changing_param
 434 01f0 F091 0000 		lds r31,changing_param+1
 435 01f4 4AE0      		ldi r20,lo8(10)
 436 01f6 50E0      		ldi r21,0
 437 01f8 BE01      		movw r22,r28
 438 01fa 6F5F      		subi r22,-1
 439 01fc 7F4F      		sbci r23,-1
 440 01fe 8081      		ld r24,Z
 441 0200 9181      		ldd r25,Z+1
 442 0202 0E94 0000 		call itoa
 443               	.LVL25:
 478:src/main.c    **** 	lcd_puts("                 ");
 444               		.loc 1 478 0
 445 0206 62E0      		ldi r22,lo8(2)
 446 0208 80E0      		ldi r24,0
 447 020a 0E94 0000 		call lcd_gotoxy
 448               	.LVL26:
 479:src/main.c    **** 	lcd_gotoxy(0,2);
 449               		.loc 1 479 0
 450 020e 80E0      		ldi r24,lo8(.LC9)
 451 0210 90E0      		ldi r25,hi8(.LC9)
 452 0212 0E94 0000 		call lcd_puts
 453               	.LVL27:
 480:src/main.c    **** 	lcd_puts(toDraw);
 454               		.loc 1 480 0
 455 0216 62E0      		ldi r22,lo8(2)
 456 0218 80E0      		ldi r24,0
 457 021a 0E94 0000 		call lcd_gotoxy
 458               	.LVL28:
 481:src/main.c    **** }
 459               		.loc 1 481 0
 460 021e CE01      		movw r24,r28
 461 0220 0196      		adiw r24,1
 462 0222 0E94 0000 		call lcd_puts
 463               	.LVL29:
 464               	/* epilogue start */
 482:src/main.c    **** 
 465               		.loc 1 482 0
 466 0226 6E96      		adiw r28,30
 467 0228 0FB6      		in __tmp_reg__,__SREG__
 468 022a F894      		cli
 469 022c DEBF      		out __SP_H__,r29
 470 022e 0FBE      		out __SREG__,__tmp_reg__
 471 0230 CDBF      		out __SP_L__,r28
 472 0232 DF91      		pop r29
 473 0234 CF91      		pop r28
 474 0236 0895      		ret
 475               		.cfi_endproc
 476               	.LFE21:
 478               	.global	param_next
 480               	param_next:
 481               	.LFB18:
 415:src/main.c    **** 	param_id++;
 482               		.loc 1 415 0
 483               		.cfi_startproc
 484               	/* prologue: function */
 485               	/* frame size = 0 */
 486               	/* stack size = 0 */
 487               	.L__stack_usage = 0
 416:src/main.c    **** 
 488               		.loc 1 416 0
 489 0238 8091 0000 		lds r24,param_id
 490 023c 8F5F      		subi r24,lo8(-(1))
 418:src/main.c    **** 		param_id=0;
 491               		.loc 1 418 0
 492 023e 8730      		cpi r24,lo8(7)
 493 0240 00F4      		brsh .L24
 416:src/main.c    **** 
 494               		.loc 1 416 0
 495 0242 8093 0000 		sts param_id,r24
 496 0246 00C0      		rjmp .L25
 497               	.L24:
 419:src/main.c    **** 
 498               		.loc 1 419 0
 499 0248 1092 0000 		sts param_id,__zero_reg__
 500               	.L25:
 421:src/main.c    **** }
 501               		.loc 1 421 0
 502 024c 0C94 0000 		jmp param_show
 503               	.LVL30:
 504               		.cfi_endproc
 505               	.LFE18:
 507               	.global	param_up
 509               	param_up:
 510               	.LFB19:
 425:src/main.c    **** 	(*changing_param)++;
 511               		.loc 1 425 0
 512               		.cfi_startproc
 513               	/* prologue: function */
 514               	/* frame size = 0 */
 515               	/* stack size = 0 */
 516               	.L__stack_usage = 0
 426:src/main.c    **** 	param_show();	
 517               		.loc 1 426 0
 518 0250 E091 0000 		lds r30,changing_param
 519 0254 F091 0000 		lds r31,changing_param+1
 520 0258 8081      		ld r24,Z
 521 025a 9181      		ldd r25,Z+1
 522 025c 0196      		adiw r24,1
 523 025e 9183      		std Z+1,r25
 524 0260 8083      		st Z,r24
 427:src/main.c    **** }
 525               		.loc 1 427 0
 526 0262 0C94 0000 		jmp param_show
 527               	.LVL31:
 528               		.cfi_endproc
 529               	.LFE19:
 531               	.global	param_down
 533               	param_down:
 534               	.LFB20:
 431:src/main.c    **** 	(*changing_param)--;
 535               		.loc 1 431 0
 536               		.cfi_startproc
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 0 */
 540               	.L__stack_usage = 0
 432:src/main.c    **** 	param_show();	
 541               		.loc 1 432 0
 542 0266 E091 0000 		lds r30,changing_param
 543 026a F091 0000 		lds r31,changing_param+1
 544 026e 8081      		ld r24,Z
 545 0270 9181      		ldd r25,Z+1
 546 0272 0197      		sbiw r24,1
 547 0274 9183      		std Z+1,r25
 548 0276 8083      		st Z,r24
 433:src/main.c    **** }
 549               		.loc 1 433 0
 550 0278 0C94 0000 		jmp param_show
 551               	.LVL32:
 552               		.cfi_endproc
 553               	.LFE20:
 555               		.section	.rodata.str1.1
 556               	.LC10:
 557 00b4 4163 7469 		.string	"Active: CAM "
 557      7665 3A20 
 557      4341 4D20 
 557      00
 558               	.LC11:
 559 00c1 5061 6E3A 		.string	"Pan: %3d Tilt: %3d"
 559      2025 3364 
 559      2054 696C 
 559      743A 2025 
 559      3364 00
 560               		.text
 561               	.global	main_show
 563               	main_show:
 564               	.LFB12:
 331:src/main.c    **** 	lcd_gotoxy(0,1);
 565               		.loc 1 331 0
 566               		.cfi_startproc
 567 027c 0F93      		push r16
 568               	.LCFI8:
 569               		.cfi_def_cfa_offset 3
 570               		.cfi_offset 16, -2
 571 027e 1F93      		push r17
 572               	.LCFI9:
 573               		.cfi_def_cfa_offset 4
 574               		.cfi_offset 17, -3
 575 0280 CF93      		push r28
 576               	.LCFI10:
 577               		.cfi_def_cfa_offset 5
 578               		.cfi_offset 28, -4
 579 0282 DF93      		push r29
 580               	.LCFI11:
 581               		.cfi_def_cfa_offset 6
 582               		.cfi_offset 29, -5
 583 0284 CDB7      		in r28,__SP_L__
 584 0286 DEB7      		in r29,__SP_H__
 585               	.LCFI12:
 586               		.cfi_def_cfa_register 28
 587 0288 6597      		sbiw r28,21
 588               	.LCFI13:
 589               		.cfi_def_cfa_offset 27
 590 028a 0FB6      		in __tmp_reg__,__SREG__
 591 028c F894      		cli
 592 028e DEBF      		out __SP_H__,r29
 593 0290 0FBE      		out __SREG__,__tmp_reg__
 594 0292 CDBF      		out __SP_L__,r28
 595               	/* prologue: function */
 596               	/* frame size = 21 */
 597               	/* stack size = 25 */
 598               	.L__stack_usage = 25
 332:src/main.c    **** 	lcd_puts("Active: CAM ");
 599               		.loc 1 332 0
 600 0294 61E0      		ldi r22,lo8(1)
 601 0296 80E0      		ldi r24,0
 602 0298 0E94 0000 		call lcd_gotoxy
 603               	.LVL33:
 333:src/main.c    **** 	char tmp[21];
 604               		.loc 1 333 0
 605 029c 80E0      		ldi r24,lo8(.LC10)
 606 029e 90E0      		ldi r25,hi8(.LC10)
 607 02a0 0E94 0000 		call lcd_puts
 608               	.LVL34:
 335:src/main.c    **** 	lcd_gotoxy(12,1);
 609               		.loc 1 335 0
 610 02a4 8091 0000 		lds r24,active_cam
 611 02a8 90E0      		ldi r25,0
 612 02aa 4AE0      		ldi r20,lo8(10)
 613 02ac 50E0      		ldi r21,0
 614 02ae 8E01      		movw r16,r28
 615 02b0 0F5F      		subi r16,-1
 616 02b2 1F4F      		sbci r17,-1
 617 02b4 B801      		movw r22,r16
 618 02b6 0196      		adiw r24,1
 619 02b8 0E94 0000 		call itoa
 620               	.LVL35:
 336:src/main.c    **** 	lcd_puts(tmp);
 621               		.loc 1 336 0
 622 02bc 61E0      		ldi r22,lo8(1)
 623 02be 8CE0      		ldi r24,lo8(12)
 624 02c0 0E94 0000 		call lcd_gotoxy
 625               	.LVL36:
 337:src/main.c    **** 
 626               		.loc 1 337 0
 627 02c4 C801      		movw r24,r16
 628 02c6 0E94 0000 		call lcd_puts
 629               	.LVL37:
 339:src/main.c    **** 	sprintf(tmp,"Pan: %3d Tilt: %3d", cams[active_cam].pan, cams[active_cam].tilt);
 630               		.loc 1 339 0
 631 02ca 62E0      		ldi r22,lo8(2)
 632 02cc 80E0      		ldi r24,0
 633 02ce 0E94 0000 		call lcd_gotoxy
 634               	.LVL38:
 340:src/main.c    **** 	lcd_puts(tmp);
 635               		.loc 1 340 0
 636 02d2 E091 0000 		lds r30,active_cam
 637 02d6 80E2      		ldi r24,lo8(32)
 638 02d8 E89F      		mul r30,r24
 639 02da F001      		movw r30,r0
 640 02dc 1124      		clr __zero_reg__
 641 02de E050      		subi r30,lo8(-(cams))
 642 02e0 F040      		sbci r31,hi8(-(cams))
 643 02e2 8785      		ldd r24,Z+15
 644 02e4 1F92      		push __zero_reg__
 645 02e6 8F93      		push r24
 646 02e8 8685      		ldd r24,Z+14
 647 02ea 1F92      		push __zero_reg__
 648 02ec 8F93      		push r24
 649 02ee 80E0      		ldi r24,lo8(.LC11)
 650 02f0 90E0      		ldi r25,hi8(.LC11)
 651 02f2 9F93      		push r25
 652 02f4 8F93      		push r24
 653 02f6 1F93      		push r17
 654 02f8 0F93      		push r16
 655 02fa 0E94 0000 		call sprintf
 656               	.LVL39:
 341:src/main.c    **** }	
 657               		.loc 1 341 0
 658 02fe C801      		movw r24,r16
 659 0300 0E94 0000 		call lcd_puts
 660               	.LVL40:
 661 0304 0FB6      		in __tmp_reg__,__SREG__
 662 0306 F894      		cli
 663 0308 DEBF      		out __SP_H__,r29
 664 030a 0FBE      		out __SREG__,__tmp_reg__
 665 030c CDBF      		out __SP_L__,r28
 666               	/* epilogue start */
 342:src/main.c    **** 
 667               		.loc 1 342 0
 668 030e 6596      		adiw r28,21
 669 0310 0FB6      		in __tmp_reg__,__SREG__
 670 0312 F894      		cli
 671 0314 DEBF      		out __SP_H__,r29
 672 0316 0FBE      		out __SREG__,__tmp_reg__
 673 0318 CDBF      		out __SP_L__,r28
 674 031a DF91      		pop r29
 675 031c CF91      		pop r28
 676 031e 1F91      		pop r17
 677 0320 0F91      		pop r16
 678 0322 0895      		ret
 679               		.cfi_endproc
 680               	.LFE12:
 682               	.global	save_data
 684               	save_data:
 685               	.LFB23:
 487:src/main.c    **** }
 488:src/main.c    **** 
 489:src/main.c    **** void save_data(void)
 490:src/main.c    **** {
 686               		.loc 1 490 0
 687               		.cfi_startproc
 688               	/* prologue: function */
 689               	/* frame size = 0 */
 690               	/* stack size = 0 */
 691               	.L__stack_usage = 0
 491:src/main.c    **** 	eeprom_write_block (cams, backup_cams, sizeof(cams));
 692               		.loc 1 491 0
 693 0324 40E8      		ldi r20,lo8(-128)
 694 0326 50E0      		ldi r21,0
 695 0328 60E0      		ldi r22,lo8(backup_cams)
 696 032a 70E0      		ldi r23,hi8(backup_cams)
 697 032c 80E0      		ldi r24,lo8(cams)
 698 032e 90E0      		ldi r25,hi8(cams)
 699 0330 0C94 0000 		jmp eeprom_write_block
 700               	.LVL41:
 701               		.cfi_endproc
 702               	.LFE23:
 704               	.global	update_leds
 706               	update_leds:
 707               	.LFB9:
 172:src/main.c    **** 	//update the store leds if the leds are not flashing
 708               		.loc 1 172 0
 709               		.cfi_startproc
 710 0334 CF93      		push r28
 711               	.LCFI14:
 712               		.cfi_def_cfa_offset 3
 713               		.cfi_offset 28, -2
 714 0336 DF93      		push r29
 715               	.LCFI15:
 716               		.cfi_def_cfa_offset 4
 717               		.cfi_offset 29, -3
 718               	/* prologue: function */
 719               	/* frame size = 0 */
 720               	/* stack size = 2 */
 721               	.L__stack_usage = 2
 174:src/main.c    **** 	{
 722               		.loc 1 174 0
 723 0338 8091 0000 		lds r24,active_menu
 724 033c 8450      		subi r24,lo8(-(-4))
 725 033e 8230      		cpi r24,lo8(2)
 726 0340 00F0      		brlo .L30
 727 0342 C0E0      		ldi r28,0
 728 0344 D0E0      		ldi r29,0
 729               	.L31:
 730               	.LVL42:
 731               	.LBB7:
 179:src/main.c    **** 			{
 732               		.loc 1 179 0
 733 0346 8091 0000 		lds r24,active_cam
 734 034a 9E01      		movw r18,r28
 735 034c 40E1      		ldi r20,lo8(16)
 736 034e 849F      		mul r24,r20
 737 0350 200D      		add r18,r0
 738 0352 311D      		adc r19,r1
 739 0354 1124      		clr __zero_reg__
 740 0356 C901      		movw r24,r18
 741 0358 F901      		movw r30,r18
 742 035a EE0F      		lsl r30
 743 035c FF1F      		rol r31
 744 035e E050      		subi r30,lo8(-(cams+16))
 745 0360 F040      		sbci r31,hi8(-(cams+16))
 746 0362 2081      		ld r18,Z
 747 0364 3181      		ldd r19,Z+1
 748 0366 2F3F      		cpi r18,-1
 749 0368 3F4F      		sbci r19,-1
 750 036a 01F0      		breq .L32
 179:src/main.c    **** 			{
 751               		.loc 1 179 0 is_stmt 0 discriminator 1
 752 036c 880F      		lsl r24
 753 036e 991F      		rol r25
 754 0370 FC01      		movw r30,r24
 755 0372 E050      		subi r30,lo8(-(cams+24))
 756 0374 F040      		sbci r31,hi8(-(cams+24))
 757 0376 8081      		ld r24,Z
 758 0378 9181      		ldd r25,Z+1
 759 037a 0196      		adiw r24,1
 760 037c 01F0      		breq .L32
 181:src/main.c    **** 			}
 761               		.loc 1 181 0 is_stmt 1
 762 037e 8C2F      		mov r24,r28
 763 0380 0E94 0000 		call set_store_led
 764               	.LVL43:
 765 0384 00C0      		rjmp .L33
 766               	.L32:
 185:src/main.c    **** 			}
 767               		.loc 1 185 0
 768 0386 8C2F      		mov r24,r28
 769 0388 0E94 0000 		call reset_store_led
 770               	.LVL44:
 771               	.L33:
 176:src/main.c    **** 		{
 772               		.loc 1 176 0 discriminator 2
 773 038c 2196      		adiw r28,1
 774               	.LVL45:
 775 038e C430      		cpi r28,4
 776 0390 D105      		cpc r29,__zero_reg__
 777 0392 01F4      		brne .L31
 778               	.LVL46:
 779               	.L30:
 780               	/* epilogue start */
 781               	.LBE7:
 190:src/main.c    **** 
 782               		.loc 1 190 0
 783 0394 DF91      		pop r29
 784 0396 CF91      		pop r28
 785 0398 0895      		ret
 786               		.cfi_endproc
 787               	.LFE9:
 789               	.global	set_menu
 791               	set_menu:
 792               	.LFB14:
 362:src/main.c    **** 	active_menu = menu;
 793               		.loc 1 362 0
 794               		.cfi_startproc
 795               	.LVL47:
 796 039a CF93      		push r28
 797               	.LCFI16:
 798               		.cfi_def_cfa_offset 3
 799               		.cfi_offset 28, -2
 800 039c DF93      		push r29
 801               	.LCFI17:
 802               		.cfi_def_cfa_offset 4
 803               		.cfi_offset 29, -3
 804               	/* prologue: function */
 805               	/* frame size = 0 */
 806               	/* stack size = 2 */
 807               	.L__stack_usage = 2
 808 039e C82F      		mov r28,r24
 363:src/main.c    **** 	lcd_clrscr();
 809               		.loc 1 363 0
 810 03a0 8093 0000 		sts active_menu,r24
 364:src/main.c    **** 	lcd_puts(menues[menu].lines[0]);
 811               		.loc 1 364 0
 812 03a4 0E94 0000 		call lcd_clrscr
 813               	.LVL48:
 365:src/main.c    **** 	lcd_gotoxy(0,1);
 814               		.loc 1 365 0
 815 03a8 86E1      		ldi r24,lo8(22)
 816 03aa C89F      		mul r28,r24
 817 03ac E001      		movw r28,r0
 818 03ae 1124      		clr __zero_reg__
 819               	.LVL49:
 820 03b0 C050      		subi r28,lo8(-(menues))
 821 03b2 D040      		sbci r29,hi8(-(menues))
 822 03b4 8881      		ld r24,Y
 823 03b6 9981      		ldd r25,Y+1
 824 03b8 0E94 0000 		call lcd_puts
 825               	.LVL50:
 366:src/main.c    **** 	lcd_puts(menues[menu].lines[1]);
 826               		.loc 1 366 0
 827 03bc 61E0      		ldi r22,lo8(1)
 828 03be 80E0      		ldi r24,0
 829 03c0 0E94 0000 		call lcd_gotoxy
 830               	.LVL51:
 367:src/main.c    **** 	lcd_gotoxy(0,2);
 831               		.loc 1 367 0
 832 03c4 8A81      		ldd r24,Y+2
 833 03c6 9B81      		ldd r25,Y+3
 834 03c8 0E94 0000 		call lcd_puts
 835               	.LVL52:
 368:src/main.c    **** 	lcd_puts(menues[menu].lines[2]);
 836               		.loc 1 368 0
 837 03cc 62E0      		ldi r22,lo8(2)
 838 03ce 80E0      		ldi r24,0
 839 03d0 0E94 0000 		call lcd_gotoxy
 840               	.LVL53:
 369:src/main.c    **** 	lcd_gotoxy(0,3);
 841               		.loc 1 369 0
 842 03d4 8C81      		ldd r24,Y+4
 843 03d6 9D81      		ldd r25,Y+5
 844 03d8 0E94 0000 		call lcd_puts
 845               	.LVL54:
 370:src/main.c    **** 	lcd_puts(menues[menu].lines[3]);
 846               		.loc 1 370 0
 847 03dc 63E0      		ldi r22,lo8(3)
 848 03de 80E0      		ldi r24,0
 849 03e0 0E94 0000 		call lcd_gotoxy
 850               	.LVL55:
 371:src/main.c    **** 
 851               		.loc 1 371 0
 852 03e4 8E81      		ldd r24,Y+6
 853 03e6 9F81      		ldd r25,Y+7
 854 03e8 0E94 0000 		call lcd_puts
 855               	.LVL56:
 373:src/main.c    **** 		menues[menu].init();
 856               		.loc 1 373 0
 857 03ec EC89      		ldd r30,Y+20
 858 03ee FD89      		ldd r31,Y+21
 859 03f0 3097      		sbiw r30,0
 860 03f2 01F0      		breq .L44
 374:src/main.c    **** 
 861               		.loc 1 374 0
 862 03f4 0995      		icall
 863               	.LVL57:
 864               	.L44:
 865               	/* epilogue start */
 378:src/main.c    **** 
 866               		.loc 1 378 0
 867 03f6 DF91      		pop r29
 868 03f8 CF91      		pop r28
 376:src/main.c    **** 
 869               		.loc 1 376 0
 870 03fa 0C94 0000 		jmp update_leds
 871               	.LVL58:
 872               		.cfi_endproc
 873               	.LFE14:
 875               	.global	process_inputs
 877               	process_inputs:
 878               	.LFB10:
 195:src/main.c    **** 	//Fetch keypress from hardware
 879               		.loc 1 195 0
 880               		.cfi_startproc
 881 03fe CF93      		push r28
 882               	.LCFI18:
 883               		.cfi_def_cfa_offset 3
 884               		.cfi_offset 28, -2
 885 0400 DF93      		push r29
 886               	.LCFI19:
 887               		.cfi_def_cfa_offset 4
 888               		.cfi_offset 29, -3
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 2 */
 892               	.L__stack_usage = 2
 197:src/main.c    **** 
 893               		.loc 1 197 0
 894 0402 0E94 0000 		call get_camkeys
 895               	.LVL59:
 200:src/main.c    **** 	{
 896               		.loc 1 200 0
 897 0406 8130      		cpi r24,lo8(1)
 898 0408 01F0      		breq .L53
 899 040a 00F0      		brlo .L51
 900 040c 8230      		cpi r24,lo8(2)
 901 040e 01F0      		breq .L53
 902 0410 8330      		cpi r24,lo8(3)
 903 0412 01F0      		breq .L53
 904 0414 00C0      		rjmp .L87
 905               	.L51:
 202:src/main.c    **** 		case CAM2: active_cam = 1; break; 
 906               		.loc 1 202 0
 907 0416 1092 0000 		sts active_cam,__zero_reg__
 908 041a 00C0      		rjmp .L55
 909               	.L53:
 205:src/main.c    **** 		default: break;
 910               		.loc 1 205 0
 911 041c 8093 0000 		sts active_cam,r24
 912 0420 00C0      		rjmp .L55
 913               	.L87:
 210:src/main.c    **** 	{
 914               		.loc 1 210 0
 915 0422 8F3F      		cpi r24,lo8(-1)
 916 0424 01F0      		breq .L56
 917               	.L55:
 213:src/main.c    **** 
 918               		.loc 1 213 0
 919 0426 8091 0000 		lds r24,active_cam
 920               	.LVL60:
 921 042a 0E94 0000 		call set_cam_leds
 922               	.LVL61:
 215:src/main.c    **** 
 923               		.loc 1 215 0
 924 042e 0E94 0000 		call update_leds
 925               	.LVL62:
 218:src/main.c    **** 			main_show();
 926               		.loc 1 218 0
 927 0432 8091 0000 		lds r24,active_menu
 928 0436 8130      		cpi r24,lo8(1)
 929 0438 01F4      		brne .L56
 219:src/main.c    **** 
 930               		.loc 1 219 0
 931 043a 0E94 0000 		call main_show
 932               	.LVL63:
 933               	.L56:
 227:src/main.c    **** uint8_t old_pan = cams[active_cam].pan;
 934               		.loc 1 227 0
 935 043e E091 0000 		lds r30,active_cam
 936 0442 20E2      		ldi r18,lo8(32)
 937 0444 E29F      		mul r30,r18
 938 0446 F001      		movw r30,r0
 939 0448 1124      		clr __zero_reg__
 940 044a E050      		subi r30,lo8(-(cams))
 941 044c F040      		sbci r31,hi8(-(cams))
 942 044e D785      		ldd r29,Z+15
 943               	.LVL64:
 228:src/main.c    **** 	
 944               		.loc 1 228 0
 945 0450 C685      		ldd r28,Z+14
 946               	.LVL65:
 230:src/main.c    **** 	if(analog%8==0)
 947               		.loc 1 230 0
 948 0452 8091 0000 		lds r24,analog.2167
 949 0456 8F5F      		subi r24,lo8(-(1))
 950 0458 8093 0000 		sts analog.2167,r24
 231:src/main.c    **** 	{
 951               		.loc 1 231 0
 952 045c 8770      		andi r24,lo8(7)
 953 045e 01F0      		breq .+2
 954 0460 00C0      		rjmp .L58
 955               	.LBB8:
 234:src/main.c    **** 		if(cams[active_cam].pan_invert)
 956               		.loc 1 234 0
 957 0462 6285      		ldd r22,Z+10
 958 0464 7385      		ldd r23,Z+11
 959 0466 0E94 0000 		call axis_offset
 960               	.LVL66:
 235:src/main.c    **** 		{
 961               		.loc 1 235 0
 962 046a 2091 0000 		lds r18,active_cam
 963 046e 40E2      		ldi r20,lo8(32)
 964 0470 249F      		mul r18,r20
 965 0472 9001      		movw r18,r0
 966 0474 1124      		clr __zero_reg__
 967 0476 F901      		movw r30,r18
 968 0478 E050      		subi r30,lo8(-(cams))
 969 047a F040      		sbci r31,hi8(-(cams))
 970 047c 4681      		ldd r20,Z+6
 971 047e 5781      		ldd r21,Z+7
 972 0480 452B      		or r20,r21
 973 0482 01F0      		breq .L59
 237:src/main.c    **** 		}
 974               		.loc 1 237 0
 975 0484 9195      		neg r25
 976 0486 8195      		neg r24
 977 0488 9109      		sbc r25,__zero_reg__
 978               	.LVL67:
 979               	.L59:
 240:src/main.c    **** 			cams[active_cam].pan=255;
 980               		.loc 1 240 0
 981 048a F901      		movw r30,r18
 982 048c E050      		subi r30,lo8(-(cams))
 983 048e F040      		sbci r31,hi8(-(cams))
 984 0490 4685      		ldd r20,Z+14
 985 0492 BC01      		movw r22,r24
 986 0494 640F      		add r22,r20
 987 0496 711D      		adc r23,__zero_reg__
 988 0498 6F3F      		cpi r22,-1
 989 049a 7105      		cpc r23,__zero_reg__
 990 049c 01F0      		breq .L60
 991 049e 04F0      		brlt .L60
 241:src/main.c    **** 		else if( (int16_t)cams[active_cam].pan+diff < 0)
 992               		.loc 1 241 0
 993 04a0 8FEF      		ldi r24,lo8(-1)
 994               	.LVL68:
 995 04a2 00C0      		rjmp .L84
 996               	.LVL69:
 997               	.L60:
 242:src/main.c    **** 			cams[active_cam].pan=0;
 998               		.loc 1 242 0
 999 04a4 77FF      		sbrs r23,7
 1000 04a6 00C0      		rjmp .L62
 243:src/main.c    **** 		else
 1001               		.loc 1 243 0
 1002 04a8 1686      		std Z+14,__zero_reg__
 1003 04aa 00C0      		rjmp .L61
 1004               	.L62:
 245:src/main.c    **** 
 1005               		.loc 1 245 0
 1006 04ac 840F      		add r24,r20
 1007               	.LVL70:
 1008               	.L84:
 1009 04ae 8687      		std Z+14,r24
 1010               	.L61:
 248:src/main.c    **** 		if(cams[active_cam].tilt_invert)
 1011               		.loc 1 248 0
 1012 04b0 F901      		movw r30,r18
 1013 04b2 E050      		subi r30,lo8(-(cams))
 1014 04b4 F040      		sbci r31,hi8(-(cams))
 1015 04b6 6485      		ldd r22,Z+12
 1016 04b8 7585      		ldd r23,Z+13
 1017 04ba 81E0      		ldi r24,lo8(1)
 1018 04bc 0E94 0000 		call axis_offset
 1019               	.LVL71:
 249:src/main.c    **** 		{
 1020               		.loc 1 249 0
 1021 04c0 E091 0000 		lds r30,active_cam
 1022 04c4 60E2      		ldi r22,lo8(32)
 1023 04c6 E69F      		mul r30,r22
 1024 04c8 F001      		movw r30,r0
 1025 04ca 1124      		clr __zero_reg__
 1026 04cc DF01      		movw r26,r30
 1027 04ce A050      		subi r26,lo8(-(cams))
 1028 04d0 B040      		sbci r27,hi8(-(cams))
 1029 04d2 1896      		adiw r26,8
 1030 04d4 2D91      		ld r18,X+
 1031 04d6 3C91      		ld r19,X
 1032 04d8 1997      		sbiw r26,8+1
 1033 04da 232B      		or r18,r19
 1034 04dc 01F4      		brne .L63
 248:src/main.c    **** 		if(cams[active_cam].tilt_invert)
 1035               		.loc 1 248 0
 1036 04de 9195      		neg r25
 1037 04e0 8195      		neg r24
 1038 04e2 9109      		sbc r25,__zero_reg__
 1039               	.LVL72:
 1040               	.L63:
 255:src/main.c    **** 			cams[active_cam].tilt=255;
 1041               		.loc 1 255 0
 1042 04e4 E050      		subi r30,lo8(-(cams))
 1043 04e6 F040      		sbci r31,hi8(-(cams))
 1044 04e8 2785      		ldd r18,Z+15
 1045 04ea AC01      		movw r20,r24
 1046 04ec 420F      		add r20,r18
 1047 04ee 511D      		adc r21,__zero_reg__
 1048 04f0 4F3F      		cpi r20,-1
 1049 04f2 5105      		cpc r21,__zero_reg__
 1050 04f4 01F0      		breq .L64
 1051 04f6 04F0      		brlt .L64
 256:src/main.c    **** 		else if( (int16_t)cams[active_cam].tilt+diff < 0)
 1052               		.loc 1 256 0
 1053 04f8 8FEF      		ldi r24,lo8(-1)
 1054               	.LVL73:
 1055 04fa 00C0      		rjmp .L85
 1056               	.LVL74:
 1057               	.L64:
 257:src/main.c    **** 			cams[active_cam].tilt=0;
 1058               		.loc 1 257 0
 1059 04fc 57FF      		sbrs r21,7
 1060 04fe 00C0      		rjmp .L65
 258:src/main.c    **** 		else
 1061               		.loc 1 258 0
 1062 0500 1786      		std Z+15,__zero_reg__
 1063 0502 00C0      		rjmp .L58
 1064               	.L65:
 260:src/main.c    **** 	}
 1065               		.loc 1 260 0
 1066 0504 820F      		add r24,r18
 1067               	.LVL75:
 1068               	.L85:
 1069 0506 8787      		std Z+15,r24
 1070               	.L58:
 1071               	.LBE8:
 264:src/main.c    **** 
 1072               		.loc 1 264 0
 1073 0508 0E94 0000 		call get_storekeys
 1074               	.LVL76:
 266:src/main.c    **** 	{
 1075               		.loc 1 266 0
 1076 050c 8F3F      		cpi r24,lo8(-1)
 1077 050e 01F4      		brne .+2
 1078 0510 00C0      		rjmp .L66
 1079               	.LVL77:
 1080               	.LBB9:
 271:src/main.c    **** 		{
 1081               		.loc 1 271 0
 1082 0512 9927      		clr r25
 1083               	.LVL78:
 1084 0514 0197      		sbiw r24,1
 1085 0516 8330      		cpi r24,3
 1086 0518 9105      		cpc r25,__zero_reg__
 1087 051a 00F4      		brsh .L73
 1088 051c FC01      		movw r30,r24
 1089 051e E050      		subi r30,lo8(-(CSWTCH.50))
 1090 0520 F040      		sbci r31,hi8(-(CSWTCH.50))
 1091 0522 8081      		ld r24,Z
 1092 0524 00C0      		rjmp .L67
 1093               	.L73:
 1094 0526 80E0      		ldi r24,0
 1095               	.L67:
 1096               	.LVL79:
 281:src/main.c    **** 		{
 1097               		.loc 1 281 0
 1098 0528 2091 0000 		lds r18,active_menu
 1099 052c A091 0000 		lds r26,active_cam
 1100 0530 90E0      		ldi r25,0
 1101 0532 2430      		cpi r18,lo8(4)
 1102 0534 01F4      		brne .L68
 283:src/main.c    **** 			cams[active_cam].store_tilt[store_id] = cams[active_cam].tilt;
 1103               		.loc 1 283 0
 1104 0536 20E1      		ldi r18,lo8(16)
 1105 0538 A29F      		mul r26,r18
 1106 053a 800D      		add r24,r0
 1107 053c 911D      		adc r25,r1
 1108 053e 1124      		clr __zero_reg__
 1109               	.LVL80:
 1110 0540 FC01      		movw r30,r24
 1111 0542 EE0F      		lsl r30
 1112 0544 FF1F      		rol r31
 1113 0546 E050      		subi r30,lo8(-(cams+16))
 1114 0548 F040      		sbci r31,hi8(-(cams+16))
 1115 054a 40E2      		ldi r20,lo8(32)
 1116 054c A49F      		mul r26,r20
 1117 054e D001      		movw r26,r0
 1118 0550 1124      		clr __zero_reg__
 1119 0552 A050      		subi r26,lo8(-(cams))
 1120 0554 B040      		sbci r27,hi8(-(cams))
 1121 0556 1E96      		adiw r26,14
 1122 0558 2C91      		ld r18,X
 1123 055a 1E97      		sbiw r26,14
 1124 055c 30E0      		ldi r19,0
 1125 055e 3183      		std Z+1,r19
 1126 0560 2083      		st Z,r18
 284:src/main.c    **** 			save_data(); //write data to EEPROM
 1127               		.loc 1 284 0
 1128 0562 880F      		lsl r24
 1129 0564 991F      		rol r25
 1130 0566 FC01      		movw r30,r24
 1131 0568 E050      		subi r30,lo8(-(cams+24))
 1132 056a F040      		sbci r31,hi8(-(cams+24))
 1133 056c 1F96      		adiw r26,15
 1134 056e 8C91      		ld r24,X
 1135 0570 90E0      		ldi r25,0
 1136 0572 9183      		std Z+1,r25
 1137 0574 8083      		st Z,r24
 1138 0576 00C0      		rjmp .L86
 1139               	.LVL81:
 1140               	.L68:
 288:src/main.c    **** 		{
 1141               		.loc 1 288 0
 1142 0578 2530      		cpi r18,lo8(5)
 1143 057a 01F4      		brne .L69
 290:src/main.c    **** 			cams[active_cam].store_tilt[store_id]=0xFFFF;
 1144               		.loc 1 290 0
 1145 057c 60E1      		ldi r22,lo8(16)
 1146 057e A69F      		mul r26,r22
 1147 0580 800D      		add r24,r0
 1148 0582 911D      		adc r25,r1
 1149 0584 1124      		clr __zero_reg__
 1150               	.LVL82:
 1151 0586 FC01      		movw r30,r24
 1152 0588 EE0F      		lsl r30
 1153 058a FF1F      		rol r31
 1154 058c E050      		subi r30,lo8(-(cams+16))
 1155 058e F040      		sbci r31,hi8(-(cams+16))
 1156 0590 2FEF      		ldi r18,lo8(-1)
 1157 0592 3FEF      		ldi r19,lo8(-1)
 1158 0594 3183      		std Z+1,r19
 1159 0596 2083      		st Z,r18
 291:src/main.c    **** 			save_data(); //write data to EEPROM
 1160               		.loc 1 291 0
 1161 0598 880F      		lsl r24
 1162 059a 991F      		rol r25
 1163 059c FC01      		movw r30,r24
 1164 059e E050      		subi r30,lo8(-(cams+24))
 1165 05a0 F040      		sbci r31,hi8(-(cams+24))
 1166 05a2 3183      		std Z+1,r19
 1167 05a4 2083      		st Z,r18
 1168               	.L86:
 292:src/main.c    **** 			set_menu(MENU_MAIN); //jump back to main menu
 1169               		.loc 1 292 0
 1170 05a6 0E94 0000 		call save_data
 1171               	.LVL83:
 293:src/main.c    **** 		}
 1172               		.loc 1 293 0
 1173 05aa 81E0      		ldi r24,lo8(1)
 1174 05ac 0E94 0000 		call set_menu
 1175               	.LVL84:
 1176 05b0 00C0      		rjmp .L66
 1177               	.LVL85:
 1178               	.L69:
 298:src/main.c    **** 			{
 1179               		.loc 1 298 0
 1180 05b2 2A2F      		mov r18,r26
 1181 05b4 30E0      		ldi r19,0
 1182 05b6 40E1      		ldi r20,lo8(16)
 1183 05b8 A49F      		mul r26,r20
 1184 05ba 800D      		add r24,r0
 1185 05bc 911D      		adc r25,r1
 1186 05be 1124      		clr __zero_reg__
 1187               	.LVL86:
 1188 05c0 FC01      		movw r30,r24
 1189 05c2 EE0F      		lsl r30
 1190 05c4 FF1F      		rol r31
 1191 05c6 E050      		subi r30,lo8(-(cams+16))
 1192 05c8 F040      		sbci r31,hi8(-(cams+16))
 1193 05ca 4081      		ld r20,Z
 1194 05cc 5181      		ldd r21,Z+1
 1195 05ce 4F3F      		cpi r20,-1
 1196 05d0 6FEF      		ldi r22,-1
 1197 05d2 5607      		cpc r21,r22
 1198 05d4 01F0      		breq .L66
 298:src/main.c    **** 			{
 1199               		.loc 1 298 0 is_stmt 0 discriminator 1
 1200 05d6 880F      		lsl r24
 1201 05d8 991F      		rol r25
 1202 05da FC01      		movw r30,r24
 1203 05dc E050      		subi r30,lo8(-(cams+24))
 1204 05de F040      		sbci r31,hi8(-(cams+24))
 1205 05e0 8081      		ld r24,Z
 1206 05e2 9181      		ldd r25,Z+1
 1207 05e4 0196      		adiw r24,1
 1208 05e6 01F0      		breq .L66
 300:src/main.c    **** 				cams[active_cam].tilt = cams[active_cam].store_tilt[store_id];;
 1209               		.loc 1 300 0 is_stmt 1
 1210 05e8 D901      		movw r26,r18
 1211 05ea 85E0      		ldi r24,5
 1212               		1:
 1213 05ec AA0F      		lsl r26
 1214 05ee BB1F      		rol r27
 1215 05f0 8A95      		dec r24
 1216 05f2 01F4      		brne 1b
 1217 05f4 A050      		subi r26,lo8(-(cams))
 1218 05f6 B040      		sbci r27,hi8(-(cams))
 1219 05f8 1E96      		adiw r26,14
 1220 05fa 4C93      		st X,r20
 1221 05fc 1E97      		sbiw r26,14
 301:src/main.c    **** 			}
 1222               		.loc 1 301 0
 1223 05fe 8081      		ld r24,Z
 1224 0600 1F96      		adiw r26,15
 1225 0602 8C93      		st X,r24
 1226               	.L66:
 1227               	.LBE9:
 308:src/main.c    **** 	{
 1228               		.loc 1 308 0
 1229 0604 E091 0000 		lds r30,active_cam
 1230 0608 80E2      		ldi r24,lo8(32)
 1231 060a E89F      		mul r30,r24
 1232 060c F001      		movw r30,r0
 1233 060e 1124      		clr __zero_reg__
 1234 0610 DF01      		movw r26,r30
 1235 0612 A050      		subi r26,lo8(-(cams))
 1236 0614 B040      		sbci r27,hi8(-(cams))
 1237 0616 1F96      		adiw r26,15
 1238 0618 8C91      		ld r24,X
 1239 061a 1F97      		sbiw r26,15
 1240 061c D813      		cpse r29,r24
 1241 061e 00C0      		rjmp .L70
 308:src/main.c    **** 	{
 1242               		.loc 1 308 0 is_stmt 0 discriminator 1
 1243 0620 1E96      		adiw r26,14
 1244 0622 8C91      		ld r24,X
 1245 0624 C817      		cp r28,r24
 1246 0626 01F0      		breq .L48
 1247               	.L70:
 311:src/main.c    **** 		write_dmx(cams[active_cam].base_addr + cams[active_cam].tilt_address, cams[active_cam].tilt);
 1248               		.loc 1 311 0 is_stmt 1
 1249 0628 E050      		subi r30,lo8(-(cams))
 1250 062a F040      		sbci r31,hi8(-(cams))
 1251 062c 2281      		ldd r18,Z+2
 1252 062e 3381      		ldd r19,Z+3
 1253 0630 8081      		ld r24,Z
 1254 0632 9181      		ldd r25,Z+1
 1255 0634 6685      		ldd r22,Z+14
 1256 0636 820F      		add r24,r18
 1257 0638 931F      		adc r25,r19
 1258 063a 0E94 0000 		call write_dmx
 1259               	.LVL87:
 312:src/main.c    **** 
 1260               		.loc 1 312 0
 1261 063e E091 0000 		lds r30,active_cam
 1262 0642 20E2      		ldi r18,lo8(32)
 1263 0644 E29F      		mul r30,r18
 1264 0646 F001      		movw r30,r0
 1265 0648 1124      		clr __zero_reg__
 1266 064a E050      		subi r30,lo8(-(cams))
 1267 064c F040      		sbci r31,hi8(-(cams))
 1268 064e 2481      		ldd r18,Z+4
 1269 0650 3581      		ldd r19,Z+5
 1270 0652 8081      		ld r24,Z
 1271 0654 9181      		ldd r25,Z+1
 1272 0656 6785      		ldd r22,Z+15
 1273 0658 820F      		add r24,r18
 1274 065a 931F      		adc r25,r19
 1275 065c 0E94 0000 		call write_dmx
 1276               	.LVL88:
 315:src/main.c    **** 			main_show();
 1277               		.loc 1 315 0
 1278 0660 8091 0000 		lds r24,active_menu
 1279 0664 8130      		cpi r24,lo8(1)
 1280 0666 01F4      		brne .L48
 1281               	/* epilogue start */
 319:src/main.c    **** 
 1282               		.loc 1 319 0
 1283 0668 DF91      		pop r29
 1284               	.LVL89:
 1285 066a CF91      		pop r28
 1286               	.LVL90:
 316:src/main.c    **** 	}	
 1287               		.loc 1 316 0
 1288 066c 0C94 0000 		jmp main_show
 1289               	.LVL91:
 1290               	.L48:
 1291               	/* epilogue start */
 319:src/main.c    **** 
 1292               		.loc 1 319 0
 1293 0670 DF91      		pop r29
 1294               	.LVL92:
 1295 0672 CF91      		pop r28
 1296               	.LVL93:
 1297 0674 0895      		ret
 1298               		.cfi_endproc
 1299               	.LFE10:
 1301               	.global	process_menu
 1303               	process_menu:
 1304               	.LFB13:
 345:src/main.c    **** 	softkey_t button = get_softkeys();
 1305               		.loc 1 345 0
 1306               		.cfi_startproc
 1307 0676 CF93      		push r28
 1308               	.LCFI20:
 1309               		.cfi_def_cfa_offset 3
 1310               		.cfi_offset 28, -2
 1311 0678 DF93      		push r29
 1312               	.LCFI21:
 1313               		.cfi_def_cfa_offset 4
 1314               		.cfi_offset 29, -3
 1315               	/* prologue: function */
 1316               	/* frame size = 0 */
 1317               	/* stack size = 2 */
 1318               	.L__stack_usage = 2
 346:src/main.c    **** 
 1319               		.loc 1 346 0
 1320 067a 0E94 0000 		call get_softkeys
 1321               	.LVL94:
 348:src/main.c    **** 	{
 1322               		.loc 1 348 0
 1323 067e 8F3F      		cpi r24,lo8(-1)
 1324 0680 01F0      		breq .L88
 350:src/main.c    **** 				menues[active_menu].cb[button]();	
 1325               		.loc 1 350 0
 1326 0682 C82F      		mov r28,r24
 1327 0684 D0E0      		ldi r29,0
 1328 0686 8091 0000 		lds r24,active_menu
 1329               	.LVL95:
 1330 068a FE01      		movw r30,r28
 1331 068c 9BE0      		ldi r25,lo8(11)
 1332 068e 899F      		mul r24,r25
 1333 0690 E00D      		add r30,r0
 1334 0692 F11D      		adc r31,r1
 1335 0694 1124      		clr __zero_reg__
 1336 0696 EE0F      		lsl r30
 1337 0698 FF1F      		rol r31
 1338 069a E050      		subi r30,lo8(-(menues+12))
 1339 069c F040      		sbci r31,hi8(-(menues+12))
 1340 069e 0190      		ld __tmp_reg__,Z+
 1341 06a0 F081      		ld r31,Z
 1342 06a2 E02D      		mov r30,__tmp_reg__
 1343 06a4 3097      		sbiw r30,0
 1344 06a6 01F0      		breq .L91
 351:src/main.c    **** 
 1345               		.loc 1 351 0
 1346 06a8 0995      		icall
 1347               	.LVL96:
 1348               	.L91:
 353:src/main.c    **** 			set_menu(menues[active_menu].next[button]);
 1349               		.loc 1 353 0
 1350 06aa 8091 0000 		lds r24,active_menu
 1351 06ae 96E1      		ldi r25,lo8(22)
 1352 06b0 899F      		mul r24,r25
 1353 06b2 C00D      		add r28,r0
 1354 06b4 D11D      		adc r29,r1
 1355 06b6 1124      		clr __zero_reg__
 1356               	.LVL97:
 1357 06b8 C050      		subi r28,lo8(-(menues))
 1358 06ba D040      		sbci r29,hi8(-(menues))
 1359 06bc 8885      		ldd r24,Y+8
 1360 06be 8F3F      		cpi r24,lo8(-1)
 1361 06c0 01F0      		breq .L88
 1362               	/* epilogue start */
 359:src/main.c    **** 
 1363               		.loc 1 359 0
 1364 06c2 DF91      		pop r29
 1365 06c4 CF91      		pop r28
 354:src/main.c    **** 	
 1366               		.loc 1 354 0
 1367 06c6 0C94 0000 		jmp set_menu
 1368               	.LVL98:
 1369               	.L88:
 1370               	/* epilogue start */
 359:src/main.c    **** 
 1371               		.loc 1 359 0
 1372 06ca DF91      		pop r29
 1373 06cc CF91      		pop r28
 1374 06ce 0895      		ret
 1375               		.cfi_endproc
 1376               	.LFE13:
 1378               		.section	.text.startup,"ax",@progbits
 1379               	.global	main
 1381               	main:
 1382               	.LFB8:
 129:src/main.c    **** 	//initialise stuff
 1383               		.loc 1 129 0
 1384               		.cfi_startproc
 1385               	/* prologue: function */
 1386               	/* frame size = 0 */
 1387               	/* stack size = 0 */
 1388               	.L__stack_usage = 0
 131:src/main.c    **** 	eeprom_read_block (cams, backup_cams, sizeof(cams));
 1389               		.loc 1 131 0
 1390 0000 0E94 0000 		call hardware_init
 1391               	.LVL99:
 132:src/main.c    **** 
 1392               		.loc 1 132 0
 1393 0004 40E8      		ldi r20,lo8(-128)
 1394 0006 50E0      		ldi r21,0
 1395 0008 60E0      		ldi r22,lo8(backup_cams)
 1396 000a 70E0      		ldi r23,hi8(backup_cams)
 1397 000c 80E0      		ldi r24,lo8(cams)
 1398 000e 90E0      		ldi r25,hi8(cams)
 1399 0010 0E94 0000 		call eeprom_read_block
 1400               	.LVL100:
 134:src/main.c    **** 	set_menu(MENU_SPLASH);
 1401               		.loc 1 134 0
 1402 0014 8CE0      		ldi r24,lo8(12)
 1403 0016 0E94 0000 		call lcd_init
 1404               	.LVL101:
 135:src/main.c    **** 	dmx_init();
 1405               		.loc 1 135 0
 1406 001a 80E0      		ldi r24,0
 1407 001c 0E94 0000 		call set_menu
 1408               	.LVL102:
 136:src/main.c    **** 	ADC_Init();
 1409               		.loc 1 136 0
 1410 0020 0E94 0000 		call dmx_init
 1411               	.LVL103:
 137:src/main.c    **** 
 1412               		.loc 1 137 0
 1413 0024 0E94 0000 		call ADC_Init
 1414               	.LVL104:
 139:src/main.c    **** 	uint16_t blink_counter=0;
 1415               		.loc 1 139 0
 1416 0028 8091 0000 		lds r24,active_cam
 1417 002c 0E94 0000 		call set_cam_leds
 1418               	.LVL105:
 140:src/main.c    **** 	while(1)
 1419               		.loc 1 140 0
 1420 0030 C0E0      		ldi r28,0
 1421 0032 D0E0      		ldi r29,0
 153:src/main.c    **** 		{
 1422               		.loc 1 153 0
 1423 0034 04E1      		ldi r16,lo8(20)
 1424 0036 10E0      		ldi r17,0
 159:src/main.c    **** 		{
 1425               		.loc 1 159 0
 1426 0038 88E2      		ldi r24,lo8(40)
 1427 003a E82E      		mov r14,r24
 1428 003c F12C      		mov r15,__zero_reg__
 1429               	.LVL106:
 1430               	.L105:
 143:src/main.c    **** 
 1431               		.loc 1 143 0
 1432 003e 2196      		adiw r28,1
 1433               	.LVL107:
 146:src/main.c    **** 		
 1434               		.loc 1 146 0
 1435 0040 0E94 0000 		call process_inputs
 1436               	.LVL108:
 149:src/main.c    **** 		
 1437               		.loc 1 149 0
 1438 0044 0E94 0000 		call process_menu
 1439               	.LVL109:
 153:src/main.c    **** 		{
 1440               		.loc 1 153 0
 1441 0048 8091 0000 		lds r24,active_menu
 1442 004c 8450      		subi r24,lo8(-(-4))
 1443 004e 8230      		cpi r24,lo8(2)
 1444 0050 00F0      		brlo .L100
 1445               	.L103:
 159:src/main.c    **** 		{
 1446               		.loc 1 159 0
 1447 0052 8091 0000 		lds r24,active_menu
 1448 0056 8450      		subi r24,lo8(-(-4))
 1449 0058 8230      		cpi r24,lo8(2)
 1450 005a 00F4      		brsh .L104
 1451 005c 00C0      		rjmp .L106
 1452               	.L100:
 153:src/main.c    **** 		{
 1453               		.loc 1 153 0 discriminator 1
 1454 005e CE01      		movw r24,r28
 1455 0060 B801      		movw r22,r16
 1456 0062 0E94 0000 		call __udivmodhi4
 1457 0066 892B      		or r24,r25
 1458 0068 01F4      		brne .L103
 1459               	.LVL110:
 1460               	.LBB10:
 156:src/main.c    **** 		}
 1461               		.loc 1 156 0
 1462 006a 80E0      		ldi r24,0
 1463 006c 0E94 0000 		call reset_store_led
 1464               	.LVL111:
 1465 0070 81E0      		ldi r24,lo8(1)
 1466 0072 0E94 0000 		call reset_store_led
 1467               	.LVL112:
 1468 0076 82E0      		ldi r24,lo8(2)
 1469 0078 0E94 0000 		call reset_store_led
 1470               	.LVL113:
 1471 007c 83E0      		ldi r24,lo8(3)
 1472 007e 0E94 0000 		call reset_store_led
 1473               	.LVL114:
 1474 0082 00C0      		rjmp .L103
 1475               	.LVL115:
 1476               	.L106:
 1477               	.LBE10:
 159:src/main.c    **** 		{
 1478               		.loc 1 159 0 discriminator 1
 1479 0084 CE01      		movw r24,r28
 1480 0086 B701      		movw r22,r14
 1481 0088 0E94 0000 		call __udivmodhi4
 1482 008c 892B      		or r24,r25
 1483 008e 01F4      		brne .L104
 1484               	.LVL116:
 1485               	.LBB11:
 162:src/main.c    **** 		}
 1486               		.loc 1 162 0
 1487 0090 80E0      		ldi r24,0
 1488 0092 0E94 0000 		call set_store_led
 1489               	.LVL117:
 1490 0096 81E0      		ldi r24,lo8(1)
 1491 0098 0E94 0000 		call set_store_led
 1492               	.LVL118:
 1493 009c 82E0      		ldi r24,lo8(2)
 1494 009e 0E94 0000 		call set_store_led
 1495               	.LVL119:
 1496 00a2 83E0      		ldi r24,lo8(3)
 1497 00a4 0E94 0000 		call set_store_led
 1498               	.LVL120:
 1499               	.L104:
 1500               	.LBE11:
 1501               	.LBB12:
 1502               	.LBB13:
 1503               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1504               		.loc 2 163 0
 1505 00a8 8FE1      		ldi r24,lo8(19999)
 1506 00aa 9EE4      		ldi r25,hi8(19999)
 1507 00ac 0197      	1:	sbiw r24,1
 1508 00ae 01F4      		brne 1b
 1509 00b0 00C0      		rjmp .
 1510 00b2 0000      		nop
 1511 00b4 00C0      		rjmp .L105
 1512               	.LBE13:
 1513               	.LBE12:
 1514               		.cfi_endproc
 1515               	.LFE8:
 1517               		.section	.rodata
 1520               	CSWTCH.50:
 1521 0000 01        		.byte	1
 1522 0001 02        		.byte	2
 1523 0002 03        		.byte	3
 1524               		.local	analog.2167
 1525               		.comm	analog.2167,1,1
 1526               		.comm	changing_param,2,1
 1527               	.global	param_id
 1528               		.section .bss
 1531               	param_id:
 1532 0000 00        		.zero	1
 1533               	.global	setup_active_cam
 1536               	setup_active_cam:
 1537 0001 00        		.zero	1
 1538               	.global	menues
 1539               		.section	.rodata.str1.1
 1540               	.LC12:
 1541 00d4 4472 6167 		.string	"DragonVideo        "
 1541      6F6E 5669 
 1541      6465 6F20 
 1541      2020 2020 
 1541      2020 2000 
 1542               	.LC13:
 1543 00e8 4279 204B 		.string	"By Karrn            "
 1543      6172 726E 
 1543      2020 2020 
 1543      2020 2020 
 1543      2020 2020 
 1544               	.LC14:
 1545 00fd 4361 6D20 		.string	"Cam controller      "
 1545      636F 6E74 
 1545      726F 6C6C 
 1545      6572 2020 
 1545      2020 2020 
 1546               	.LC15:
 1547 0112 2020 2020 		.string	"                2017"
 1547      2020 2020 
 1547      2020 2020 
 1547      2020 2020 
 1547      3230 3137 
 1548               	.LC16:
 1549 0127 2020 2020 		.string	"                    "
 1549      2020 2020 
 1549      2020 2020 
 1549      2020 2020 
 1549      2020 2020 
 1550               	.LC17:
 1551 013c 5354 4F52 		.string	"STORE          SETUP"
 1551      4520 2020 
 1551      2020 2020 
 1551      2020 2053 
 1551      4554 5550 
 1552               	.LC18:
 1553 0151 5365 7475 		.string	"Setup              "
 1553      7020 2020 
 1553      2020 2020 
 1553      2020 2020 
 1553      2020 2000 
 1554               	.LC19:
 1555 0165 5052 4556 		.string	"PREV NEXT MOD.  BACK"
 1555      204E 4558 
 1555      5420 4D4F 
 1555      442E 2020 
 1555      4241 434B 
 1556               	.LC20:
 1557 017a 4E45 5854 		.string	"NEXT UP   DOWN  BACK"
 1557      2055 5020 
 1557      2020 444F 
 1557      574E 2020 
 1557      4241 434B 
 1558               	.LC21:
 1559 018f 5374 6F72 		.string	"Store              "
 1559      6520 2020 
 1559      2020 2020 
 1559      2020 2020 
 1559      2020 2000 
 1560               	.LC22:
 1561 01a3 4368 6F6F 		.string	"Choose store to save"
 1561      7365 2073 
 1561      746F 7265 
 1561      2074 6F20 
 1561      7361 7665 
 1562               	.LC23:
 1563 01b8 2020 2020 		.string	"     CLEAR     ABORT"
 1563      2043 4C45 
 1563      4152 2020 
 1563      2020 2041 
 1563      424F 5254 
 1564               	.LC24:
 1565 01cd 436C 6561 		.string	"Clear store        "
 1565      7220 7374 
 1565      6F72 6520 
 1565      2020 2020 
 1565      2020 2000 
 1566               	.LC25:
 1567 01e1 4368 6F6F 		.string	"Choose store        "
 1567      7365 2073 
 1567      746F 7265 
 1567      2020 2020 
 1567      2020 2020 
 1568               	.LC26:
 1569 01f6 414C 4C20 		.string	"ALL            ABORT"
 1569      2020 2020 
 1569      2020 2020 
 1569      2020 2041 
 1569      424F 5254 
 1570               		.data
 1573               	menues:
 1574 0000 0000      		.word	.LC12
 1575 0002 0000      		.word	.LC13
 1576 0004 0000      		.word	.LC14
 1577 0006 0000      		.word	.LC15
 1578 0008 01        		.byte	1
 1579 0009 01        		.byte	1
 1580 000a 01        		.byte	1
 1581 000b 01        		.byte	1
 1582 000c 0000      		.word	0
 1583 000e 0000      		.word	0
 1584 0010 0000      		.word	0
 1585 0012 0000      		.word	0
 1586 0014 0000      		.word	0
 1587 0016 0000      		.word	.LC12
 1588 0018 0000      		.word	.LC16
 1589 001a 0000      		.word	.LC16
 1590 001c 0000      		.word	.LC17
 1591 001e 04        		.byte	4
 1592 001f FF        		.byte	-1
 1593 0020 FF        		.byte	-1
 1594 0021 02        		.byte	2
 1595 0022 0000      		.word	0
 1596 0024 0000      		.word	0
 1597 0026 0000      		.word	0
 1598 0028 0000      		.word	0
 1599 002a 0000      		.word	gs(main_show)
 1600 002c 0000      		.word	.LC18
 1601 002e 0000      		.word	.LC16
 1602 0030 0000      		.word	.LC16
 1603 0032 0000      		.word	.LC19
 1604 0034 FF        		.byte	-1
 1605 0035 FF        		.byte	-1
 1606 0036 03        		.byte	3
 1607 0037 01        		.byte	1
 1608 0038 0000      		.word	gs(setup_cam_down)
 1609 003a 0000      		.word	gs(setup_cam_up)
 1610 003c 0000      		.word	gs(param_resetId)
 1611 003e 0000      		.word	gs(save_data)
 1612 0040 0000      		.word	gs(setup_show_cam)
 1613 0042 0000      		.word	.LC18
 1614 0044 0000      		.word	.LC16
 1615 0046 0000      		.word	.LC16
 1616 0048 0000      		.word	.LC20
 1617 004a FF        		.byte	-1
 1618 004b FF        		.byte	-1
 1619 004c FF        		.byte	-1
 1620 004d 02        		.byte	2
 1621 004e 0000      		.word	gs(param_next)
 1622 0050 0000      		.word	gs(param_up)
 1623 0052 0000      		.word	gs(param_down)
 1624 0054 0000      		.word	0
 1625 0056 0000      		.word	gs(param_show)
 1626 0058 0000      		.word	.LC21
 1627 005a 0000      		.word	.LC22
 1628 005c 0000      		.word	.LC16
 1629 005e 0000      		.word	.LC23
 1630 0060 FF        		.byte	-1
 1631 0061 05        		.byte	5
 1632 0062 FF        		.byte	-1
 1633 0063 01        		.byte	1
 1634 0064 0000      		.word	0
 1635 0066 0000      		.word	0
 1636 0068 0000      		.word	0
 1637 006a 0000      		.word	0
 1638 006c 0000      		.word	0
 1639 006e 0000      		.word	.LC24
 1640 0070 0000      		.word	.LC25
 1641 0072 0000      		.word	.LC16
 1642 0074 0000      		.word	.LC26
 1643 0076 01        		.byte	1
 1644 0077 FF        		.byte	-1
 1645 0078 FF        		.byte	-1
 1646 0079 01        		.byte	1
 1647 007a 0000      		.word	gs(store_clear)
 1648 007c 0000      		.word	0
 1649 007e 0000      		.word	0
 1650 0080 0000      		.word	0
 1651 0082 0000      		.word	0
 1652               		.comm	active_cam,1,1
 1653               	.global	backup_cams
 1654               		.section	.eeprom,"aw",@progbits
 1657               	backup_cams:
 1658 0000 0000 0000 		.zero	128
 1658      0000 0000 
 1658      0000 0000 
 1658      0000 0000 
 1658      0000 0000 
 1659               		.comm	cams,128,1
 1660               		.comm	active_menu,1,1
 1661               		.text
 1662               	.Letext0:
 1663               		.file 3 "/usr/lib/avr/include/stdint.h"
 1664               		.file 4 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
 1665               		.file 5 "src/hardware.h"
 1666               		.file 6 "src/lcd.h"
 1667               		.file 7 "/usr/lib/avr/include/avr/eeprom.h"
 1668               		.file 8 "/usr/lib/avr/include/stdio.h"
 1669               		.file 9 "src/adc.h"
 1670               		.file 10 "src/dmx.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccNERspy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccNERspy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccNERspy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccNERspy.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccNERspy.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccNERspy.s:12     .text:0000000000000000 store_clear
                            *COM*:0000000000000001 active_cam
                            *COM*:0000000000000080 cams
     /tmp/ccNERspy.s:67     .text:0000000000000036 param_resetId
     /tmp/ccNERspy.s:1531   .bss:0000000000000000 param_id
     /tmp/ccNERspy.s:87     .text:000000000000003c setup_show_cam
     /tmp/ccNERspy.s:1536   .bss:0000000000000001 setup_active_cam
     /tmp/ccNERspy.s:162    .text:0000000000000098 setup_cam_up
     /tmp/ccNERspy.s:191    .text:00000000000000b0 setup_cam_down
     /tmp/ccNERspy.s:237    .text:00000000000000c4 param_show
                            *COM*:0000000000000002 changing_param
     /tmp/ccNERspy.s:480    .text:0000000000000238 param_next
     /tmp/ccNERspy.s:509    .text:0000000000000250 param_up
     /tmp/ccNERspy.s:533    .text:0000000000000266 param_down
     /tmp/ccNERspy.s:563    .text:000000000000027c main_show
     /tmp/ccNERspy.s:684    .text:0000000000000324 save_data
     /tmp/ccNERspy.s:1657   .eeprom:0000000000000000 backup_cams
     /tmp/ccNERspy.s:706    .text:0000000000000334 update_leds
                            *COM*:0000000000000001 active_menu
     /tmp/ccNERspy.s:791    .text:000000000000039a set_menu
     /tmp/ccNERspy.s:1573   .data:0000000000000000 menues
     /tmp/ccNERspy.s:877    .text:00000000000003fe process_inputs
                             .bss:0000000000000002 analog.2167
     /tmp/ccNERspy.s:1520   .rodata:0000000000000000 CSWTCH.50
     /tmp/ccNERspy.s:1303   .text:0000000000000676 process_menu
     /tmp/ccNERspy.s:1381   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
lcd_gotoxy
itoa
lcd_puts
__tablejump2__
sprintf
eeprom_write_block
set_store_led
reset_store_led
lcd_clrscr
get_camkeys
set_cam_leds
axis_offset
get_storekeys
write_dmx
get_softkeys
hardware_init
eeprom_read_block
lcd_init
dmx_init
ADC_Init
__udivmodhi4
__do_copy_data
__do_clear_bss
